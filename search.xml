<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[打印沙漏(简单思路)]]></title>
    <url>%2F%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F.html</url>
    <content type="text"><![CDATA[打印沙漏本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印 ***** *** * *** ***** 所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。 给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。 输入格式:输入在一行给出1个正整数N（≤\le≤1000）和一个符号，中间以空格分隔。 输出格式:首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。 输入样例:19 * 输出样例:***** *** * *** ***** 2 思路 ： 这里不讲百度一大堆的那种硬解的思路，而是通过python进行一个巧妙的转化 沙漏我们可以想象python里面的list列表[-3,-2,-1,0,1,2,3] 这种对称的 而打印出来 无非是找到对应的左右端口 其实就是找到沙漏的前半部分的h 我们通过大量画图模拟可以发现 给出数量和h的关系 h = \sqrt{(n+1)/2}h取整就是前半部分的加中心的值 比如n = 19 h 取整就为3 观察图形又是5行 就是模拟这个列表的过程[-2,-1,0,1,2] 如何达到？ 可以用 1map(abs,range(1-h,h)) # 来实现这个列表的模拟 接下来 我们就开始寻找 每一行输出多少个* 和 空格之间的关系了 话不多说 直接上代码 1234567n, ch = input().split(' ')n = int(n)h = int(((n + 1) / 2) ** 0.5)for i in map(abs, range(1 - h, h)): print(" " * (h - i - 1) + ch * (2 * i + 1))print(n - (2*h**2-1)) # 剩余 掌握了这h之间的关系后 同时我们也可以进行举一反三 比如给出首行的个数叫你进行相应的输出 1234n = int(input("请输入首行的*的个数："))h = int((n - 1) / 2) + 1for i in map(abs, range(1 - h, h)): print(" " * (h - 1 - i) + "*" * (i * 2 + 1))]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01机器学习入门--特征抽取]]></title>
    <url>%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B.html</url>
    <content type="text"><![CDATA[01机器学习入门—特征抽取8月了。。这几天也是边干活边学习机器学习，空余时间我还是想把这些记录下来 这里我就记录3个方法 字典特征值抽取123456789DictVectorizer(sparse=True,..)DictVectorizer.fit_transform(X) * X: array数组或者sparse矩阵 * 返回值：转换之前的数据格式DictVectorizer.get_feature_names() * 返回类别的名称DictVectorizer.transform(X) * 按照原先的标准转换 文本特征值抽取123456789CountVectorizer() # 返回词频矩阵CountVectorizer.fit_transform(X) * X: 文本或者包含文本字符串的可迭代对象 * 返回值: 返回sparse矩阵CountVectorizer.inverse_transform(X) * X: array数组或者sparse矩阵CountVectoreizer.get_feature_names() * 返回值: 单词列表 Tfidf文本特征抽取分析问题Tf: term frequency —&gt; 词的频率 idf: 逆文档频率inverse document frequency 一下内容来自维基百科 tf-idf（英语：term frequency–inverse document frequency）是一种用于信息检索与文本挖掘的常用加权技术。tf-idf是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。tf-idf加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。除了tf-idf以外，互联网上的搜索引擎还会使用基于链接分析的评级方法，以确定文件在搜索结果中出现的顺序。 Tf-idf计算公式 ——&gt; lg(总文档数量/该词出现的文档数量) tf-idf的理论依据及不足 tf-idf算法是创建在这样一个假设之上的：对区别文档最有意义的词语应该是那些在文档中出现频率高，而在整个文档集合的其他文档中出现频率少的词语，所以如果特征空间坐标系取tf词频作为测度，就可以体现同类文本的特点。另外考虑到单词区别不同类别的能力，tf-idf法认为一个单词出现的文本频数越小，它区别不同类别文本的能力就越大。因此引入了逆文本频度idf的概念，以tf和idf的乘积作为特征空间坐标系的取值测度，并用它完成对权值tf的调整，调整权值的目的在于突出重要单词，抑制次要单词。但是在本质上idf是一种试图抑制噪声的加权，并且单纯地认为文本频率小的单词就越重要，文本频率大的单词就越无用，显然这并不是完全正确的。idf的简单结构并不能有效地反映单词的重要程度和特征词的分布情况，使其无法很好地完成对权值调整的功能，所以tf-idf法的精度并不是很高。 此外，在tf-idf算法中并没有体现出单词的位置信息，对于Web文档而言，权重的计算方法应该体现出HTML的结构特征。特征词在不同的标记符中对文章内容的反映程度不同，其权重的计算方法也应不同。因此应该对于处于网页不同位置的特征词分别赋予不同的系数，然后乘以特征词的词频，以提高文本表示的效果。 例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# examplefrom sklearn.feature_extraction import DictVectorizerfrom sklearn.feature_extraction.text import CountVectorizer,TfidfVectorizerimport jiebadef WordCut(): """ 中文分词 """ con = jieba.cut("人生苦短,我用python,人生漫长,我不用python") # 转为列表 content = list(con) # 列表转为字符串，忽略空格字符等 c = ' '.join(content) return c def DictVec(): ''' 字典特征抽取 sparse矩阵 节约内存，方便读取处理 ''' dict = DictVectorizer(sparse=False) data = dict.fit_transform([&#123;"city":"北京","PM2.5":123&#125;,&#123;"city":"成都","PM2.5":5&#125;]) print(dict.get_feature_names()) print(data) return None def CountVec(): """ 文本特征值抽取 对于单个字母不进行统计，没有分类依据 """ cv = CountVectorizer() # 没有sparse矩阵调节参数# data = cv.fit_transform(["Life is short,i like python","life is long,i dislike python"])# data = cv.fit_transform(["人生苦短,我用python","人生漫长,我不用python"]) # 无法对中文进行准确的抽取 # 先要自行进行分词(可以加空格或用jieba) ans = WordCut() print(ans) data = cv.fit_transform([ans]) print(cv.get_feature_names()) print(data.toarray()) # 通过toarray()方法进行转化 def tfidfVec(): """ 文本特征值抽取 对于单个字母不进行统计，没有分类依据 """ cv = TfidfVectorizer() ans = WordCut() print(ans) data = cv.fit_transform([ans]) print(cv.get_feature_names()) print(data.toarray()) # 通过toarray()方法进行转化 if __name__ == "__main__": DictVec() CountVec() tfidfVec() 但这些远不够，特征处理是什么？ 通过特定的统计方法(数学方法)将数据转换成算法要求的数据 这里我们可以分成几大类 数值型数据： 标准缩放：API —&gt; sklearn. preprocessing 11. 归一化 标准化 缺失值 类别型数据：one-hot编码 时间类型：时间的切分 （pandas） 归一化**特点:**通过对原始数据进行变换把数据映射到（默认为[0,1]）之间 $$ X' = \frac{x-min}{max-min} \\ $$ $$ X'' = X'*(mx-mi)+mi $$ **Ps**：作用于每一列，max为一列的最大值，min为一列的最小值,那么X’’为最终结果，mx，mi分别为指定区间值默认mx为1,mi为0 那为什么我们要做这些处理呢？见下方案例 ![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hZTAxLmFsaWNkbi5jb20va2YvSGJkNDQ0OTE4NmU3ZDQ2OWU4N2Y2MDNmMjJhODYwYTlkUy5wbmc) 如果单从这三种数据来相亲肯定是不公平的 我们进行下计算 $$ (72993-35948)^2+(10.141740-6830792)^2+(1.032955-1.213192)^2 $$ 我们可以清晰的发现，里程数几乎占了总体指数的全部，所以我们要进行标准缩放 **核心目的：** **其实就是让某一个特征对最终结果不会造成更大的影响** 123456MinMaxScaler(feature_range(0,1)...)* 每个特征缩放到给定范围(默认[0,1])MinMaxScaler.fit_transform(X)* X：numpy array 格式的数据[n_samples,n_features]* 返回值：转换后的形状相同的array 归一化步骤： 实例化MinMaxScalar 通过fit_transform转换 123456789101112131415161718192021from sklearn.preprocessing import MinMaxScalerdef MM(): """ 进行归一化 :return:None """ mm = MinMaxScaler(feature_range=(2, 3)) # 返回2-3 data = mm.fit_transform([[90, 2, 10, 40], [60, 4, 15, 45], [75, 3, 13, 46]]) print(data) return Noneif __name__ == '__main__': MM(); 结果： [[3. 2. 2. 2. ] [2. 3. 3. 2.83333333] [2.5 2.5 2.6 3. ]] Ps：特定场景下最大值最小值是变化的，另外，最大值与最小值非常容易受异常点影响，所以这种方法鲁棒性（稳定性）较差，只适合传统精确小数据场景。 所以引入标准化 标准化 特点：通过对原始数据进行变化把数据变化到均值为0，方差为1的范围内 公式：- X' = \frac{x-mean}{σ} 注:作用于每一列，mean为平均值，σ为标准差(考量数据的稳定性) 对于归一化来说：如果出现异常点，影响了最大值和最小值，那么结果显然会发生改变 对于标准化来说：如果出现异常点，由于具有一定数据量，少量的异常点对于平均值的影响并不大，从而方差改变较小。 123456789101112StandardScaler(…)# 处理之后每列来说所有数据都聚集在均值0附近方差为1* StandardScaler.fit_transform(X,y) #X:numpy array格式的数据[n_samples,n_features]#返回值：转换后的形状相同的array* StandardScaler.mean_#原始数据中每列特征的平均值* StandardScaler.std_#原始数据每列特征的方差 应用： 12345678910111213141516171819202122from sklearn.preprocessing import StandardScalerdef SS(): """ 进行标准化 :return: None """ ss = StandardScaler() data = ss.fit_transform([[1., -1., 3.], [2., 4., 2.], [4., 6., -1.]]) print(data) return Noneif __name__ == '__main__': SS(); # 结果：[[-1.06904497 -1.35873244 0.98058068] [-0.26726124 0.33968311 0.39223227] [ 1.33630621 1.01904933 -1.37281295]] 平常大部分缩放都用标准化，因为在已有样本足够多的情况下比较稳定，适合现代嘈杂大数据场景。 如何处理数据中的缺失值？ 删除 如果每列或者行数据缺失值达到一定的比例，建议放弃整行或者整列 插补 可以通过缺失值每行或者每列的平均值、中位数来填充 sklearn缺失值API: sklearn.preprocessing.Imputer 123456Imputer(missing_values='NaN', strategy='mean', axis=0)#完成缺失值插补* Imputer.fit_transform(X,y) #X:numpy array格式的数据[n_samples,n_features]#返回值：转换后的形状相同的array Imputer流程 初始化Imputer,指定”缺失值”，指定填补策略，指定行或列（注：缺失值也可以是别的指定要替换的值） 调用fit_transform 123456789101112131415161718192021222324from sklearn.preprocessing import Imputerimport numpy as npdef ipt(): """ 进行缺值插入 :return: None """ ans = Imputer(missing_values="NaN", strategy="mean", axis=0) # axis = 0为列 1为行 data = ans.fit_transform([[1, 2], [np.nan, 3], [7, 6]]) print(data) return Noneif __name__ == '__main__': ipt() # 结果：[[1. 2.] [4. 3.] [7. 6.]]]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>特征值处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基本使用方法(小白)]]></title>
    <url>%2Fgit.html</url>
    <content type="text"><![CDATA[Github大型同性交友网站，连git都不会怎么快乐呢♂？不多说废话，看图 上面是不是太长了。。。别慌 下面还有一张 如果这些还不够用去我的频道收看git简明使用教程]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各类经典排序汇总(结合视频)]]></title>
    <url>%2F%E5%90%84%E7%B1%BB%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[各类基础排序汇总昨晚和几个ACM的朋友谈了会儿人生，原本危机感已经很强的我突然压力又大了起来😐，今天小程序全国晋级名单也没有我，反复扫了几遍还是没有，心一下凉了半截😌，不断学习进步才是王道呀。最近也在回顾数据结构，顺便自己也来总结一下几大经典排序算法。由于自己实力有限，若本文有任何纰漏或者大佬有什么好的建议，可以到底部留言区进行讨论与留言O(∩_∩)O 或通过右下角直接联系我噢 !! 所属类别graph TD A[排序] --> B{内部排序--使用内存}; B --> D(插入排序); D --> I(直接插入排序); D --> J(希尔排序); B --> E(选择排序); E --> K(简单选择排序); E --> L(堆排序); B --> F(交换排序); F --> M(冒泡排序); F --> N(快速排序); B --> G(归并排序); B --> H(基数排序->俗称桶排序); A --> C[外部排序--内存与外存相结合使用]; 各大排序的复杂度比较什么是稳定排序？ 待排序的记录序列中可能存在两个或两个以上关键字相等的记录。排序前的序列中Ri领先于Rj（即i&lt;j）.若在排序后的序列中Ri仍然领先于Rj，则称所用的方法是稳定的。 排序名称 平均时间复杂度 最好时间复杂度 最坏时间复杂度 空间复杂度 稳定性 建议 直接插入排序 O(N^2) O(N) [如果有序，那么每个元素都已经在在它的待排子序列的合适位置，不用找合适位置] O(N^2) O(1) 稳定 由于每次只能移动一位，建议使用希尔排序 希尔排序 O(N^1.3) O(N^2) O(N^2) O(1) 不稳定 选取合适的增量，一般选取为d = n/2，依次选下去，直到d为1 简单选择排序 O(N^2) O(N^2) O(N^2) O(1) 稳定 堆排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 不稳定 冒泡排序 O(N^2) O(N^2) O(N^2) O(1) 稳定 快速排序 O(nlog2n) O(nlog2n) O(N^2) O(nlog2n) [递归占用空间栈较多] 不稳定 归并排序 O(nlog2n) O(nlog2n) O(nlog2n) O(N) 稳定 但是这种算法很消耗空间，一般来说在内部排序不会用这种方法，而是用快速排序；外部排序才会考虑到使用这种方法 基数排序 O(D(N+R)) O(D(N+R)) O(D(N+R)) O(N+R) 稳定 各排序代码讲解贴一个排序在线动画演示，有兴趣的同学可以点进去加深印象 代码我用C来进行演示，算法重要的是思想，同学们可以尝试用自己的语言来实现 现在网络资源很多，并且好的讲解许多，关于一些排序的基本理论思想，我这给大家推荐几个视频通俗易懂 前人栽树，后人乘凉呀😁 简单排序 堆排序 归并排序 递归基础 插入排序：直接插入排序 InsertSort 主要核心理解：将一组序列分为有序和无序两个部分，每次将无序的元素在合适的index值插入到有序序列 123456789101112131415161718192021222324#include&lt;stdio.h&gt;int main()&#123; int n,a[50]; scanf("%d",&amp;n); for(int i = 0;i&lt;n;i++) &#123; scanf("%d",&amp;a[i]); &#125; for(int i = 1;i&lt;n;i++) // 从a[1]开始 因为a[0]一个数字默认有序 &#123; int key = a[i]; // 确立待插入的值 while(i &gt; 0 &amp;&amp; a[i-1] &gt; key) // 将key值与有序序列进行比较 &#123; a[i] = a[i-1]; // 前面的值往后移 i--; // 索引往前移，继续找合适的位置 &#125; a[i] = key; // 找到合适的位置了，将key插入到序列中 &#125; for(int i = 0;i&lt;n;i++) printf("%d%c",a[i],i==n-1?'\n':' '); return 0;&#125; 希尔排序 ShellSort 插入排序升级版，用增量解决直接插入排序的每次只能移动1位的缺点 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;int main()&#123; int n,a[50]; scanf("%d",&amp;n); for(int i = 0;i&lt;n;i++) &#123; scanf("%d",&amp;a[i]); &#125; int step; for(step = n/2;step &gt;= 1;step/=2) // 这里增量每次按一般取 &#123; for(int i = step;i&lt;n;i++) // 依次对按增量分类的序列进行插入排序 &#123; int j = i; int key = a[j]; while(j - step &gt;= 0 &amp;&amp; a[j-step] &gt; key) &#123; a[j] = a[j-step]; j = j - step; &#125; a[j] = key; &#125; &#125; for(int i = 0;i&lt;n;i++) printf("%d%c",a[i],i==n-1?'\n':' '); return 0;&#125; 选择排序：简单选择排序 SelectSort 每次在数组中找到最大（最小）的index值 然后与第一个值进行交换 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int main()&#123; int n,a[50]; scanf("%d",&amp;n); for(int i = 0;i&lt;n;i++) &#123; scanf("%d",&amp;a[i]); &#125; for(int i = 0;i&lt;n-1;i++) &#123; int index = i; for(int j = i+1;j&lt;n;j++) &#123; if(a[j] &gt; a[index]) &#123; index = j; &#125; &#125; int tmp = a[i]; a[i] = a[index]; a[index] = tmp; &#125; for(int i = 0;i&lt;n;i++) printf("%d%c",a[i],i==n-1?'\n':' '); return 0;&#125; 堆排序 HeapSort 其实就是利用堆这种数据结构，巧妙的进行排序，堆是一个近似完全二叉树的结构。 这里的思想见上面的堆排序视频讲解（up主讲解的通俗易懂，强烈推荐），我相信声音 + 图片的知识接收程度一定大于只看文字 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/// O(n*logn)#include&lt;stdio.h&gt;void swap(int tree[],int i,int j)&#123; int tmp = tree[i]; tree[i] = tree[j]; tree[j] = tmp;&#125;void heapify(int tree[],int n,int i)&#123; if(i&gt;=n) return; int c1 = 2*i+1; // 左节点 int c2 = 2*i+2; // 右节点 int max = i; if(c1 &lt; n &amp;&amp; tree[c1] &gt; tree[max]) &#123; max = c1; &#125; if(c2 &lt; n &amp;&amp; tree[c2] &gt; tree[max]) &#123; max = c2; &#125; if(max != i) // 若最大值的index与i不想等 就进行交换 &#123; swap(tree,max,i); heapify(tree,n,max); // 对当前最大值max节点进行递归 找出最大的值不断进行交换 &#125;&#125;void build_heap(int tree[],int n) &#123; int last_node = n - 1; int parent = (last_node - 1)/2; for(int i = parent; i &gt;= 0; i--) &#123; heapify(tree,n,i); &#125;&#125;void heap_sort(int tree[],int n)&#123; build_heap(tree,n); for(int i = n-1;i &gt;= 0;i--) &#123; swap(tree,i,0); // 最后一个节点与第一个节点交换（最小和最大的节点swap） heapify(tree,i,0); // 对最上面三个节点进行heapify 重新形成堆 这里n值用i来传 因为每次都会分离出最大值，所以节点数会每次递减1 &#125;&#125;int main()&#123; int n; int tree[50]; scanf("%d",&amp;n); for(int i = 0; i&lt;n; i++) scanf("%d",&amp;tree[i]); // heapify(tree,n,0); // build_heap(tree,n); heap_sort(tree,n); for(int i = 0; i&lt;n; i++) &#123; printf("%d%c",tree[i],i==n-1?'\n':' '); &#125; return 0;&#125; 交换排序：冒泡排序 冒泡，简单来说就是每次两两交换后都把把最大(最小)的值先放在最后面。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int main()&#123; int n,a[50]; scanf("%d",&amp;n); for(int i = 0;i&lt;n;i++) &#123; scanf("%d",&amp;a[i]); &#125; for(int i = 0;i&lt;n-1;i++) // 一共要排n-1次 &#123; /* 为什么是n-i-1呢？ 先不看减i 我们先看n-1 每次我们都是比较a[j]与a[j+1] 如果不减1 数组就会越界 再来看为什么减i 每排完一次序 就有1个最大或最小值排在最后面 所以每排了多少次 后面就应经有多少个有序的数字了 i值又是控制次数的 So每次要减i */ for(int j = 0;j&lt;n-i-1;j++) &#123; if(a[j] &gt; a[j+1]) &#123; int tmp = a[j]; a[j] = a[j + 1]; a[j+1] = tmp; &#125; &#125; &#125; for(int i = 0;i&lt;n;i++) printf("%d%c",a[i],i==n-1?'\n':' '); return 0;&#125; 快速排序 Quicksort 快速排序（Quicksort）是对冒泡排序的一种改进。不同的是，冒泡排序在每一轮只把一个元素冒泡到数列的一端，而快速排序在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成了两个部分。 我们可以看到这个动图，把大于6的分到一边，把小于6的分成一部分，再分别对这两部分进行相同的操作，直到还剩1个元素时，我们通过下面的例子来模拟一下 以一个实例模拟快速排序的过程: 设数组A为将要进行排序的数组 A=\{8,7,13,11,9,6,7,15,10,5\}快排的过程如下： 其中红色字体表示每一段子序列进行排序时所选择的基准元素，蓝色填充色的方块表示已经找到基准元素所处的位置。 从上图可以看出，每一个进行排序的序列都要经历三个过程：一是选择则基准元素（上述都选择第一个元素为基准元素），二是对基准元素进行寻址，三是将序列划分成两个子序列并重复上述的工作。 123456789101112131415161718192021222324252627282930313233343536373839404142/// O(n*logn ~ n*2)#include&lt;stdio.h&gt;void quickSort(int arr[],int l,int r)&#123; if(l &gt;= r) // 递归出口 说明只有一个元素时 回退 return; int k = arr[l]; int i,j; i = l; j = r; while(i != j) // 当左哨兵 和 右哨兵没有碰头时 进行两部分的交换 &#123; while(j&gt;i &amp;&amp; arr[j] &gt;= k) // 如果右边有比k大的就判断前一个值 否则就与哨兵i所在值进行交换 j--; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; while(i&lt;j &amp;&amp; arr[i] &lt;= k) // 如果左边有比k小的就判断后一个值 否则就与哨兵j所在值进行交换 i++; tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125; quickSort(arr,l,i-1); // 对左边递归 这里一个函数两个递归 如果不是理解很清楚的话 建议手动模拟一遍 若对递 归了解的不是很清晰 可以去之前推荐视频里看看 quickSort(arr,i+1,r); // 对右部分递归 &#125;int main()&#123; int arr[50]; int n; scanf("%d",&amp;n); for(int i = 0; i&lt;n; i++) &#123; scanf("%d",&amp;arr[i]); &#125; quickSort(arr,0,n-1); // 这里传的r和l都是索引值 for(int i = 0; i&lt;n; i++) printf("%d%c",arr[i],i==n-1?'\n':' '); return 0;&#125; 归并排序 MergeSort 归并和快排都用到了分治的思想 就是将原序列划分成两个等长子序列，再递归地排序这两个子序列，最后再调用归并操作合并成一个完整的有序数列 说白了就是 先分再合成有序 具体思想还是见上面的推荐视频 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;void merge(int arr[],int L,int R,int M)&#123; int LIET_SIZE = M - L ; int RIGHT_SIZE = R - M + 1; int lift[LIET_SIZE]; int right[RIGHT_SIZE]; int i,j,k; for(i = L;i &lt;=M ;i++) &#123; lift[i - L] = arr[i]; &#125; for(i = M;i&lt;=R;i++) &#123; right[i - M] = arr[i]; // printf("r = %d\n",right[i-M]); &#125; i = j = 0; k = L; while(i &lt; LIET_SIZE &amp;&amp; j &lt; RIGHT_SIZE) &#123; if(lift[i] &lt; right[j]) &#123; arr[k] = lift[i]; k++; i++; &#125; else &#123; arr[k] = right[j]; k++; j++; &#125; &#125; while(i &lt; LIET_SIZE) &#123; arr[k++] = lift[i]; i++; &#125; while(j &lt; RIGHT_SIZE) &#123; arr[k++] = right[j]; j++; &#125;&#125;void mergesort(int arr[],int L,int R)&#123; if(R == L) &#123; return; &#125; else&#123; int M = L + (R-L)/2; mergesort(arr,L,M); mergesort(arr,M+1,R); merge(arr,L,R,M+1); &#125;&#125;int main() &#123; int arr[10] = &#123;2,8,9,10,4,5,6,7&#125;; int R = 7; int L = 0; mergesort(arr,L,R); for(int i = 0;i&lt;8;i++) &#123; printf("%d ",arr[i]); &#125;&#125; 基数排序（不会，占时先留着）未完待续。。。]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整数分解为若干项之和(DFS小白入门)]]></title>
    <url>%2F%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3%E4%B8%BA%E8%8B%A5%E5%B9%B2%E9%A1%B9%E4%B9%8B%E5%92%8C.html</url>
    <content type="text"><![CDATA[整数分解为若干项之和(DFS小白入门)将一个正整数N分解成几个正整数相加，可以有多种分解方法，例如7=6+1，7=5+2，7=5+1+1，…。编程求出正整数N的所有整数分解式子。 输入格式：每个输入包含一个测试用例，即正整数N (0&lt;N≤30)。 输出格式：按递增顺序输出N的所有整数分解式子。递增顺序是指：对于两个分解序列N1={n1,n2,⋯}和N2={m1,m2,⋯}，若存在i使得n1=m1,⋯,n**i=m**i，但是n**i+1&lt;m**i+1,则N1序列必定在N2序列之前输出。每个式子由小到大相加，式子间用分号隔开，且每输出4个式子后换行。 输入样例：7 输出样例：7=1+1+1+1+1+1+1;7=1+1+1+1+1+2;7=1+1+1+1+3;7=1+1+1+2+2 7=1+1+1+4;7=1+1+2+3;7=1+1+5;7=1+2+2+2 7=1+2+4;7=1+3+3;7=1+6;7=2+2+3 7=2+5;7=3+4;7=7 看这种多种情况并且多种分解的 首先就要想到树 发现多种情况，和全排列有点像，果断DFS 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;#define MAX 500int a[MAX];int n;int cnt = 0,sum = 0;int k = 0;void DFS(int step)&#123; if(sum == n) // 总和与输入值相等时，进行输出 &#123; k++; printf("%d=",n); if(k%4 == 0 || a[cnt-1] == n) // 对格式进行适当的调整 &#123; for(int i = 0; i&lt;cnt; i++) &#123; printf("%d%c",a[i],i==cnt-1?'\n':'+'); &#125; &#125; else if(k%4) &#123; for(int i = 0; i&lt;cnt; i++) &#123; printf("%d%c",a[i],i==cnt-1?';':'+'); &#125; &#125; return; &#125; else if(sum &gt; n) return; for(int i = step; i&lt;=n; i++) &#123; a[cnt++] = i; sum += i; DFS(i); // 遍历下一个节点 sum -= i;// 回溯为上一个节点 所以要减去i cnt--; // 同样回溯 &#125;&#125;int main()&#123; scanf("%d",&amp;n); DFS(1); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[币值转换（模拟）]]></title>
    <url>%2F%E5%B8%81%E5%80%BC%E8%BD%AC%E6%8D%A2.html</url>
    <content type="text"><![CDATA[7-23 币值转换 (20 分) 输入一个整数（位数不超过9位）代表一个人民币值（单位为元），请转换成财务要求的大写中文格式。如23108元，转换后变成“贰万叁仟壹百零捌”元。为了简化输出，用小写英文字母a-j顺序代表大写数字0-9，用S、B、Q、W、Y分别代表拾、百、仟、万、亿。于是23108元应被转换输出为“cWdQbBai”元。 输入格式：输入在一行中给出一个不超过9位的非负整数。 输出格式：在一行中输出转换后的结果。注意“零”的用法必须符合中文习惯。 输入样例1：813227345 输出样例1：iYbQdBcScWhQdBeSf 输入样例2：6900 输出样例2：gQjB 作者: 陈建海 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;int main ()&#123; int n, initial_n; scanf("%d", &amp;n); initial_n = n; // 保留初始值 char num[10] = &#123;'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'&#125;; char unit[10] = &#123;0, 0, 'S', 'B', 'Q', 'W', 'S', 'B', 'Q', 'Y'&#125;;//舍弃前两位 char result[17]= &#123;0&#125;; // 9 位数最多有 17 位输出 int i = 0, last_i = n % 10; int j = 0; int count_n = 0; while (n &gt; 0) &#123; i = n % 10; n /= 10; count_n ++; if (i == 0 &amp;&amp; (count_n % 4) &gt; 1) // 从十位开始统计（个位0永远不输出） &#123; if (last_i != 0) // 如果前一位不等于 0，那就输出这个 0 &#123; result[j++] = num[i]; &#125; &#125; if (count_n == 5 &amp;&amp; i == 0 &amp;&amp; initial_n &lt; 100000000) &#123; result[j++] = unit[count_n]; // 万 w 是一定要输出的 &#125; if (count_n &gt; 1 &amp;&amp; i != 0) // 非 0 不输出单位 &#123; result[j++] = unit[count_n]; &#125; if (i != 0) // 处理非 0 数的输出 &#123; result[j++] = num[i]; &#125; last_i = i; //保留 i 的前一位的值 用于处理 0 &#125; if (initial_n == 0) // 处理特殊值 0 &#123; result[j++] = num[i]; &#125; for (j=j-1; j&gt;=0; j--) &#123; printf("%c", result[j]); &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux(redhat)安装gcc环境]]></title>
    <url>%2FLinux(redhat)%E5%AE%89%E8%A3%85gcc%E7%8E%AF%E5%A2%83%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%EF%BC%8C%E9%92%88%E5%AF%B9%E5%B0%8F%E7%99%BD%EF%BC%8C%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86%EF%BC%89.html</url>
    <content type="text"><![CDATA[前言：看来网上许多博客都是抄来抄去的基本一个样，还有许多坑，现在博主就来详细的介绍如何从无到有的在你的Linux环境里安装上gcc 注意:在配置gcc之前先把虚拟机的开机顺序调整正确！！！ 话不多说见图：如果不能点击就先关闭虚拟机在进行设置 现在开始 1.（先完成最上面那步再来做第一步）点击最上面的设备—&gt;分配光驱—&gt;选择你自己当前系统的.iso镜像文件选择好以后你桌面上就有一个光驱 2.开始进行挂载1）挂载光盘123cd /mntmkdir cdrommount /dev/cdrom /mnt/cdrom 2）进入软件包目录123cd /mnt/cdrom/Packagesls –la gcc*.*rpm –ivh gcc-4.4.7-3.el6.i686.rpm // 这里大家安装自己的版本(输入前几个关键字母后就用table键补齐) 不一定是我这写的版本 然后Enter进行安装，如果这安装出现问题不用管，直接进入第三步安装 3.安装以下rpm包 （从上到下依次安装，顺序一定不能乱！！）安装的时候名字不用全打,打了前面几个字母按table自动补全 注意：安装包的时候一定要根据自己包的版本安装，利用table键补齐。如果存在包的依赖关系报错的话，就先检查顺序是否正确，安装包的时候最好安装x84_64结尾的包 注意天坑: 在安装第4个rpm包的时候如果有图中红框的一定要选择图中方框这个包，不然后续会找不到对应的环境，如果没有的这个包的话还是安装i686.rpm结尾的！！！！ 12345678rpm -ivh kernel-headers-2.6.32-358.el6.i686.rpm rpm -ivh glibc-headers-2.12-1.107.el6.i686.rpm rpm -ivh glibc-devel-2.12-1.107.el6.i686.rpm rpm -ivh mpfr-2.4.1-6.el6.i686.rpm（依赖libmpfr.so.1） rpm -ivh cpp-4.4.7-3.el6.i686.rpm rpm -ivh ppl-0.10.2-11.el6.i686.rpm（依赖libppl.so.7和libppl_c.so.2）rpm -ivh cloog-ppl-0.15.7-1.2.el6.i686.rpm rpm -ivh gcc-4.4.7-3.el6.i686.rpm 4.安装好以后随便在一个文件夹中进行测试看是否成功我这是在根目录下面建了一个test文件夹 vim word.c进行编辑 在用gcc运行 大功告成，安装gcc成功，如果本文有什么错误或者知识点的遗漏欢迎大家指出！]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的询问（延时标记+差分）]]></title>
    <url>%2F%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%A2%E9%97%AE.html</url>
    <content type="text"><![CDATA[Problem A: 简单的询问Time Limit: 1 Sec Memory Limit: 64 MB Description给你N个区间[Li,Ri]，有Q个询问。 每个询问问，num这个数是否在给出的某个区间内。 Input输入第一行有一个正整数T(T&lt;=10)，表示组数； 每组数据第一行有两个正整数N,Q(N,Q]]></content>
      <categories>
        <category>算法</category>
        <category>差分数组</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Carryon 数数字(小米OJ)]]></title>
    <url>%2FCarryon%20%E6%95%B0%E6%95%B0%E5%AD%97.html</url>
    <content type="text"><![CDATA[Carryon 数数字序号：#138 难度：困难 时间限制：1000ms 内存限制：80M 描述Carryon 最近迷上了数数字，然后 Starry 给了他一个区间 [l,r] ,然后提了几个要求， 需要将 l 到 r 之间的数全部转化成 16 进制，然后连起来。 将连起来的数又转化成 10 进制。 将最终结果对 15 取模。 数据范围： $1&lt;=l&lt;=r&lt;=1000000000000$ 输入单组输入 l 和 r 的值 输出输出最终结果。 输入样例10 14 输出样例0 小提示如：10、11、12、13、14的16进制分别是a、b、c、d、e。依次连在一起是abcde，转换成10进制是703710，对15取模为0。 思路： 先看范围1~1e12 用普通for循环肯定超时，就要想怎么缩小范围，我们就先看取余 来看看为什么这里优化是 $c = a + (b - a)\%15$ 因为最后也要对15求余，我们就先对范围内取余来达到缩小范围这样也会保证结果相同以致不会超时1234567891011121314151617181920import sysfor line in sys.stdin: line = line.strip() a, b = map(int, line.split()) str = "" res = "" c = a + (b - a) % 15 # 先求个余 缩小范围 for i in range(a, c + 1): str += hex(i) # 每次加每个数的16进制 str = str.replace('0x', '') # 替换0x无用字符 for i in range(a, b + 1): ans = hex(i) res += ans res = res.replace('0x', '') print("优化前:" + res) print("优化后:" + str) print(int(str, 16) % 15) # 再从16进制转10进制取余 看下结果 123456789101112131415161718191 16优化前:123456789abcdef10优化后:111 99优化前:123456789abcdef101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f60616263优化后:123456789010 14优化前:abcde优化后:abcde02 21优化前:23456789abcdef101112131415优化后:234565 12345678910import sysfor line in sys.stdin: line = line.strip() a,b= line.split() str = "" c = int(a) + (int(b)-int(a)) % 15 # 先求个余 缩小范围 for i in range(int(a), int(c)+1): str += hex(i) # 每次加每个数的16进制 str = str.replace('0x', '') # 替换0x无用字符 print(int(str, 16) % 15) # 再从16进制转10进制取余]]></content>
      <categories>
        <category>算法</category>
        <category>取余优化</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python单线程爬取QQ空间说说存入MySQL并生成词云（超详细讲解，踩坑经历）]]></title>
    <url>%2Fpython.html</url>
    <content type="text"><![CDATA[利用python爬取好友说说并分析 看了网上的许多博客，基本上都是一个样，基本的知识也没详细解释，我这次也想跟大家仔细分析一下，自己还是要有一定爬虫基础，本人技术有限，如果本文哪有错误或不够准确的地方，还望大牛们指点ヾ(๑╹◡╹)ﾉ” 一、环境配置： Python 3.6 selenium (注意:先配置好自己浏览器的驱动，下载地址看下面) pymysql re requests 点击下载chrome的——&gt;Chrome_webdriver点击下载Firefox的——&gt;Firefox_webdriver点击下载IE的——&gt;IE_webdriver 先来张效果图看看效果 二、思路： 作为一个菜鸡学了一点爬虫，就想做一个好友的说说分析，最开始我以为这个爬虫很简单几十行就可以搞定，然而忽略了一些东西。。。。（先卖个关子） 先说说整个过程的想法： 看起来是不是很简单？（手动dog）那现在我们就来按步骤操作一下 1.找到包含好友的QQ信息的url（这里也有两种方法） 法一：先点开好友这一栏,通过亲密度的排行来获取，这里我们点开F12，选中Network一般这种信息都在XHR或者JS类型里面，大家可以在这里面找找，通过一会的寻找我们就发现friend_ship开头这xhr里面的items_list就包含了好友的QQ号和姓名，但是此方法获取的qq不全，只是大部分的qq 法二：点击页面最上面的设置按钮，滑动可见好友，通过js的结果分析，随着下滑请求的url的页数都在变化，我们只要每次修改下页数的参数就可以获取所有好友的QQ，这个方法可以获取所有的好友的qq，但对于qq好友很少的朋友来说，此方法不适用 2.找到包含好友的说说的url我们先随便点进一个好友的空间进行分析点进去过后，我们F12 进行分析，发现一页最多存20条说说，以此我们可以通过说说总数（re提取）来算出一共有多少页，然后通过构造url来获取 通过以上的分析过后我们开始获取url： 我们先看看获取qq的第一种方法的url：&gt; https://user.qzone.qq.com/proxy/domain/r.qzone.qq.com/cgi-bin/tfriend/friend_ship_manager.cgi?uin=你的QQ号&amp;do=1&amp;rd=0.55484478707938&amp;fupdate=1&amp;clean=1&amp;g_tk=1376935160&amp;qzonetoken=6e4e0b063e3f00421d98df35b330c8bb2158bb8697e5dc7a85a65b379407706960f0b1c422f9a26879&amp;g_tk=1376935160 我们分析一下这里面每次登录都在变的参数 g_tk （空间加密算法） qzonetoken （空间源码里面的参数） 那这两个参数我们要怎么获取呢？为什么每次登录这两个参数的都在变呢？ 我们首先先要了解一下——&gt;cookie在看看session的基本概念 快速查看 cookies 的方法：按F12进入浏览器的开发者模式——console——在命令行输入javascript:alert(document.cookie)，再回车即可看见 所以我们登录过后，每次都访问url的时候都要保持着参数不变，也就是说cookie不能变每次都要是同一个cookie(就相当于每次都是以你的身份保持着登录状态去访问他人空间)，否则就会出现以下情况↓ 理解好以上的几个问题过后，问题就解决了一大部分了接着我们分析g_tk参数，在自己qq空间主页 F12 点JS类型文件，找到以下文件,查看Preview部分，分析一下其中的代码 其实这个程序的意思， 还是直接上代码吧1234567891011def get_tk(cookie): hashes = 5381 for i in cookie['p_skey']: #提取cookie中p_skey每个字母 hashes += (hashes &lt;&lt; 5) + ord(i) #加密过程,ord()将 字符转化为ASCII码 # &lt;&lt; 二进制 左移运算 左移几位就相当于乘以2的几次方 return hashes &amp; 2147483647 #二进制 与运算 # 比如 2&amp;3 转为二进制 10&amp;11 # 都是1结果为1，否则为0 # 所以二进制算出来是 10 返回2 # 还不懂的朋友，还是自行Baidu吧 随着我们分析第二个参数qzonetoken这个参数很好获取，在我们空间主页右键查看网页源代码,Ctrl+F查找下可以找到，之后我们可以通过正则提取ok，理解了上面的全部，基本就完成了80%了，接下来我们开始代码实现 三、代码实现：先导入第三方库1234567import re, requestsimport time, pymysqlfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as EC 首先是登录，我们这里用selenium模拟浏览器实现 1234567891011121314151617181920def login(): driver = webdriver.Chrome() # 传入浏览器对象 wait = WebDriverWait(driver, 5) # 显式等待 driver.get('https://qzone.qq.com/') driver.switch_to_frame('login_frame') #切换到登录窗口 input = wait.until(EC.presence_of_element_located((By.ID, 'switcher_plogin')))# 显式等待 找到账号密码登录按钮 time.sleep(1) input.click() # 交互点击 driver.find_element_by_id('u').clear() #清空里面的内容 driver.find_element_by_id('u').send_keys('your_qq') #传入你的QQ time.sleep(3) driver.find_element_by_id('p').clear() driver.find_element_by_id('p').send_keys('your_password') #传入你的密码 button = driver.find_element_by_id('login_button') #找到登录按钮 time.sleep(3) button.click() time.sleep(1) driver.switch_to.default_content() # 将frame重新定位回来，不然后续会出错 return driver 通过传回来的driver对象获取网页源代码和cookies 通过源代码获取qzonetoken参数1234def get_qzonetoken(html): paa = re.compile(r'window\.g_qzonetoken = \(function\(\)\&#123; try\&#123;return "(.*?)";\&#125; catch\(e\)', re.S) res = re.findall(paa, html)[0] # 因为返回的是列表形式，所以只取第一个元素 return res 注意：driver.get_cookies()获取的cookies是散的，所以要进行以下操作： 1234567891011def get_tk(cookie): #加密过程 hashes = 5381 for i in cookie['p_skey']: hashes += (hashes &lt;&lt; 5) + ord(i) return hashes &amp; 2147483647 cookies = driver.get_cookies() for item in cookies: cookie[item['name']] = item['value'] #将对应表达联系起来 # 上一步不懂的可以把 cookies的值输出来看一下 g_tk = get_tk(cookie) 3.将cookies传给requests,以保证都是在登录状态（最关键）12345678910111213141516171819def back_session(driver): mysession = requests.session() # 建立一个session对话 cookies = driver.get_cookies() cookie = &#123;&#125; for item in cookies: cookie[item['name']] = item['value'] headers = &#123; 'authority': 'user.qzone.qq.com', 'referer': 'https://qzone.qq.com/', 'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'accept-encoding': 'gzip, deflate, br', 'accept-language': 'zh-CN,zh;q=0.9', 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36' &#125; c = requests.utils.cookiejar_from_dict(cookie, cookiejar=None, overwrite=True) # 将字典转化为cookiejar形式 mysession.headers = headers # 请求头，防止反爬 mysession.cookies.update(c) # 更新cookies return mysession # 返回带cookies的requests 存入MySQL 12345678910connection = pymysql.connect(host='your_host', port=3306, user='你的账户', passwd='你的密码', db='your_database')connection.autocommit(True) #开启自动提交 不然每次执行def save_mysql(say, stime, QQ, connection): #这里我存入说说、说说时间、qq号 stime = str(stime) content = str(say) QQ = str(QQ) sql = 'insert into qq values ("&#123;&#125;","&#123;&#125;","&#123;&#125;")'.format(content, stime, QQ) connection.query(sql)# 数据库建表的时候 一定要把字符集改成utf8 看看效果图，爬了40多分钟，四万多条数据，有点小慢。。。，很慢。大家可以尝试下多线程爬取 完成以上步骤之后整个框架就都搭好了，其余数据的提取大家就先自己完成了吧（本文最后会给出GitHub地址），也希望大家看思路过后，自己操作，不仅仅是copy、paste and run 导出某个好友的数据库，用Notepad++过滤一些数据后，通过词云分析1234567891011121314151617181920212223242526272829303132import jiebafrom matplotlib import pyplot as pltfrom wordcloud import WordCloudfrom PIL import Imageimport numpy as nppath = r'your_data.text_path'font = r'C:\Windows\Fonts\simkai.TTF' # 字体pathtext = (open('C:/Users/hp/Desktop/233.txt', 'r', encoding='utf-8')).read() # 如果是中文的话encoding换成utf8cut = jieba.cut(text) # 分词string = ' '.join(cut)print(len(string))img = Image.open('your_photo_path') # 打开图片img_array = np.array(img) # 将图片装换为数组stopword = ['xa0'] # 设置停止词，也就是你不想显示的词，这里这个词是我前期处理没处理好，你可以删掉他看看他的作用wc = WordCloud( scale=4, #清晰度 background_color='white', #背景颜色 max_words=400, #最多单词 width=1000, height=800, mask=img_array, font_path=font, stopwords=stopword # 停用词)wc.generate_from_text(string) # 绘制图片plt.imshow(wc)plt.axis('off')plt.figure()#plt.show() # 显示图片wc.to_file('F:/3.png') # 保存图片 最后我么就分析到以下图片，字越大说明出现次数最多 最后贴上我的代码链接 https://github.com/Leaderzhangyi/QQspider 希望大家能够共同改进]]></content>
      <categories>
        <category>网络爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬楼梯问题路径保存及输出（DFS小白练习）]]></title>
    <url>%2F%E7%88%AC%E6%A5%BC%E6%A2%AFdfs.html</url>
    <content type="text"><![CDATA[大家最开始做爬楼梯问题肯定都是那个递归版本（斐波拉契数列），这次写这篇文章呢是因为浙江大学C++的一道课后练习题，顺便对dfs小白起一个练习作用，题意如下 废话不多说，直接上代码 我们先考虑没有步数限制的情况如何输出路径123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1000;int n,cnt;int a[maxn];void dfs(int sum,int step)&#123; if(sum == n) // 判断和是否和输入的n值相等 &#123; printf("%d",a[0]); for(int i = 1; i&lt;step; i++) &#123; printf("-%d",a[i]); &#125; printf("\n"); return ; &#125; for(int i = 1; i&lt;=3; i++) // 这里的i的范围是一步能走多少台阶 &#123; if(sum + i &lt;= n) &#123; a[cnt++] = i; dfs(sum+i,step+1); cnt--; // 返回上一层的时候 下标也要往后退一步 &#125; &#125;&#125;int main()&#123; while(~scanf("%d",&amp;n)) &#123; memset(a,0,sizeof(a)); // 初始化数组 cnt = 0; // 下标初始化 dfs(0,0); &#125; return 0;&#125; 步数限制版本1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int maxn = 1000;int n,cnt,temp,m;int a[maxn];void dfs(int sum,int step)&#123; if(sum == n &amp;&amp; step == m) // 步数限制加在判断里面就ok &#123; cout&lt;&lt;a[0]; for(int i = 1; i&lt;step; i++) &#123; cout&lt;&lt;"-"&lt;&lt;a[i]; &#125; cout&lt;&lt;endl; temp++; // 方法总数 return ; &#125; for(int i = 1; i&lt;=3; i++) &#123; if(sum + i &lt;= n) &#123; a[cnt++] = i; dfs(sum+i,step+1); cnt--; &#125; &#125;&#125;int main()&#123; while(~scanf("%d %d",&amp;n,&amp;m)) &#123; memset(a,0,sizeof(a)); cnt = temp = 0; dfs(0,0); cout&lt;&lt;"方法一共有 "&lt;&lt;temp&lt;&lt;" 种"&lt;&lt;endl; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
</search>
