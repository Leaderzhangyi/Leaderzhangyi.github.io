<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Char范围讨论]]></title>
    <url>%2Fchar%E8%8C%83%E5%9B%B4%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[在 C 语言中， signed char 类型的范围为 -128~127，每本教科书上也这么写，但是没有哪一本书上（包括老师）也不会给你为什么是 -128~127，这个问题貌似看起来也很简单容易， 以至于不用去思考为什么，不是有一个整型范围的公式吗： -2^(n-1)~2^(n-1)-1 (n 为整型的内存占用位数)，所以 int 类型 32 位那么就是 -(2^31) ~ 2^31-1 即 -2147483648~2147483647，但是为什么最小负数绝对值总比最大正数多 1 ，这个问题甚至有的工作几年的程序员都模棱两可，因为没有深入思考过，只知道书上这么写。于是，我不得不深入思考一下这个被许多人忽视的问题。 计算机中的数值是以补码形式存储的（只不过正数的补码跟原码一样） 对于无符号整数，很简单，全部位都表示数值，比如 char 型，8 位，用二进制表示为 0000 0000 ~ 1111 1111，1111 1111 最大即为十进制 255，所以 unsigned char 的范围为 0~ 255，在这里普及一下 2 进制转十进制的方法， 二进制每一位的数值乘以它的位权 (2^(n-1)，n 为自右向左的位)，再相加，可得到十进制数，比如 ：1111 1111 = 1*2^7 + 1*2^6 + 1*2^5 + 1*2^4 + 1*2^3 + 1*2^2 + 1*2^1 + 1*2^0 = 255 。 但是对于有符号整数，二进制的最高位表示正负，不表示数值，最高位为 0 时表示正数，为 1 时表示负数，这样一来，能表示数值的就剩下 (n-1) 位了，比如 char a = -1; 那么二进制表示就为 1 0000001，1 表示为 0 0000001，所以 signed char 型除去符号位剩下的 7 位最大为 1111 111 = 127，再把符号加上，0 1111111 = 127，1 1111111 = -127，范围应该为 -127~127 ，同理 int 类型也一样，但是问题出来了，教科书上是 -128~127 啊，下面就剖析一下这个惊人的奇葩。 再普及一下计算机内部整数存储形式，大家都知道计算机内部是以二进制来存贮数值的，无符号整数会用全部为来存储，有符号的整数，最高位当做符号位 ，其余为表示数值。 这样貌似合理， 却带来一个麻烦，当进行加法时，1+1 ： 0000 0001 + 0000 0001 ————————— 0000 0010 ……………… 2 当相减时 1-1=? 由于计算机只会加法不会减法，它会转化为 1 + (-1) ，因此： 0000 0001 + 1000 0001 ____________________ 1000 0010 …………… -2 1-1 = -2? 这显然是不对了，所以为了避免减法运算错误，计算机大神们发明出了反码，直接用最高位表示符号位的叫做原码， 上面提到的二进制都是原码形式，反码是原码除最高位其余位取反，规定：正数的反码和原码相同，负数的反码是原码除了符号位，其余为都取反，因此 -1 的源码为 1 0000001 ，反码为 1 1111110。 现在再用反码来计算 1+(-1) ： 0000 0001 + 1111 1110 ———————— 1111 1111 ………… 再转化为原码就是 1000 0000 = -0 虽然反码解决了相减的问题，却又带来一个问题：-0 ，既然 0000 0000 表示 0，那么就没有 -0 的必要， 出现 +0 = -0 = 0 ，一个 0 就够了，为了避免两个 0 的问题，计算机大师们又发明了补码，补码规定： 整数的补码是其本身，负数的补码为其反码加一 ，所以，负数转化为反码需两个步骤， 第一，先转化为反码，第二： 把反码加一。 这样 -1 的补码为 1111 1111 ，1+(-1) ： 0000 0001 + 1111 1111 ________________ 1 0000 0000 …………………… 由于 char 为 8 位，最高位 1 被丢弃结果为 0 ，运算正确。 -0 ：原码 1000 0000 的补码为 1 0000 0000 ，由于 char 是 八位 ，所以取低八位 00000000。+0 ：原码 0000 0000 ，补码为也为 0000 0000 ，虽然补码 0 都是相同的，但是有两个 0 ，既然有两个 0 ，况且 0 既不是正数，也不是负数， 用原码为 0000 0000 表示就行了。 这样一来，有符号的 char，原码都用来表示 -127~127 之间的数了，唯独剩下原码 1000 0000 没有用，用排列组合也可以算出来，0 ？？？？？？？，能表示 2^7 = 128 个数，刚好是 0~127。1 ？？？？？？？，也能表示 128 个数，总共 signed char 有 256 个数，这与 -127~127 中间是两个 0 刚好吻合。 现在再来探讨一下关于剩下的那个 1000 0000，既然 -127 ~ 0 ~ 127 都有相应的原码与其对应，那么 1000 0000 表示什么呢，当然是 -128 了，为什么是 -128 呢，网上有人说 -0 即 1000 0000 与 128 的补码相同，所以用 1000 0000 表示 -128,，这我实在是不敢苟同，或者说 -128 没有原码，只有补码 1000 0000，胡扯，既然没有原码何来补码，还有说 -128 的原码与 -0(1000 0000) 的原码相同，所以可以用 1000 0000 表示 -128，我只能说，回答得不要那么牵强， 原码 1000 0000 与 -128 的原码实际上是不同的。 但为什么能用它表示 -128 进行运算，如果不要限制为 char 型（即不要限定是 8 位），再来看，-128 的原码：1 1000 0000 ，9 位，最高位符号位，再算它的反码：1 0111 1111，进而，补码为：1 1000 0000，这是 -128 的补码，发现和原码一样，1 1000 0000 和 1000 0000 相同？如果说一样的人真是瞎了眼了，所以，-128 的原码和 -0(1000 000) 的原码是不同的，但是在 char 型中，是可以用 1000 000 表示 -128 的，关键在于 char 是 8 位，它把 -128 的最高位符号位 1 丢弃了，截断后 -128 的原码为 1000 000 和 -0 的原码相同，也就是说 1000 0000 和 -128 丢弃最高位后余下的 8 位相同，所以才可以用 -0 表示 -128，这样，当初剩余的 -0(1000 0000)，被拿来表示截断后的 -128，因为即使截断后的 -128 和 char 型范围的其他 (-127~127) 运算也不会影响结果， 所以才敢这么表示 -128。 比如 -128+(-1) ： 1000 0000 ————————— 丢弃最高位的 - 128 + 1111 1111 ————————- -1 ________________ 10111 1111 —————————char 取八位，这样结果不正确，不过没关系 ，结果 - 129 本来就超出 char 型了，当然不能表示了。 比如 -128+127： 1000 0000 + 0111 1111 ———————— 1111 1111 ——————— -1 结果正确， 所以，这就是为什么能用 1000 0000 表示 - 128 的原因。 从而也是为什么 char 是 -128~127，而不是 -127~127 ，short int 同样如此 -32768~32767 因为在 16 位中，-32768 为原码为 17 位，丢弃最高位剩下的 16 为 - 0 的原码相同。 还有一个问题，既然 -128 最高位丢弃了。那么为什么还能打印出 -128 ？ 12345// 在内存中以补码 1 1000 0000 存储，但由于是 char，所以只存储 1000 0000 char a= -128; // 既然最高位丢弃了，输出时应该是 1000 000 的原码的十进制数 - 0，但为什么能输出 - 128 呢。 printf("%d",a); 我猜想是计算机内部的一个约定，就像 float 一样 ，能用 23 位表示 24 位的精度 ，因为最高位默认为 1，到时候把 23 位取出再加 1 便可。 -128 也是同样的原理，当数据总线从内存中取出的是 1000 000 ，CPU 会给它再添最高一位，变为 1 1000 0000 这样才能转化为 -128 输出，不然 1000 0000 如何输出？这当然是我的一种推断，具体怎么实现还得问 CPU 的设计者了。 再看一个例子： 12char a=-129; printf("%d",a); // 会输入多少？？ 结果为 127 ，为什么呢？ -129 在补码为 10 0111 1111 只取后八位存储，即 0111 111 这个值刚好是 127 了，同理 -130 截断后为 126….. 如此按模轮回，关于模就先不探讨了。 那么： 123456unsigned char a= -1; if(1&gt; a)&#123; printf("大于"); &#125;else&#123; printf("小于"); &#125; 结果是什么呢？ 出人意料的是：小于，而不是大于，猫腻在你哪呢，还是存储问题： a 为 unsigned 无符号， 它的八位都用来存储数值， 没有符号位，编译器把 -1 转换为补码为 1111 1111，但由于是无符号，计算机会把 1111 11111 当做是无符号来对待，自然就是 2^8 -1 = 255 了，所以相当于是 if(1&gt; 255) 肯定是 printf(“小于”); 了。 本文转自：http://blog.csdn.net/daiyutage]]></content>
      <categories>
        <category>计算机常识</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vscode配置[转]]]></title>
    <url>%2FVscode_Set.html</url>
    <content type="text"><![CDATA[前言 文章标题：《第一次使用 VS Code 时你应该知道的一切配置》。本文的最新内容，更新于 2020-06-19。大家完全不用担心这篇文章会过时，因为随着 VS Code 的版本更新和插件更新，本文也会随之更新。 本文的最新内容，也会在GitHub上同步更新，欢迎 star。 VS Code 软件实在是太酷、太好用了，越来越多的新生代互联网青年正在使用它。 前端男神尤雨溪大大这样评价 VS Code： 有一点你可能会感到惊讶：VS Code 这款软件本身，是用 JavaScript 语言编写的（具体请自行查阅基于 JS 的 PC 客户端开发框架 Electron）。Jeff Atwood 在 2007 年提出了著名的 Atwood 定律： 任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现。 Jeff Atwood 这个人是谁不重要（他是 Stack Overflow 网站的联合创始人），重要的是这条定律。 前端目前是处在春秋战国时代，各路英雄豪杰成为后浪，各种框架工具层出不穷，VS Code 软件无疑是大前端时代最骄傲的工具。 如果你是做前端开发（JavaScript 编程语言为主），则完全可以将 VS Code 作为「主力开发工具」。这款软件是为前端同学量身定制的。 如果你是做其他语言方向的开发，并且不需要太复杂的集成开发环境，那么，你可以把 VS Code 作为「代码编辑器」来使用，纵享丝滑。 甚至是一些写文档、写作的同学，也经常把 VS Code 作为 markdown 写作工具，毫无违和感。 退而求其次，即便你不属于以上任何范畴，你还可以把 VS Code 当作最简单的文本编辑器来使用，完胜 Windows 系统自带的记事本。 写下这篇文章，是顺势而为。 一、VS Code 的介绍VS Code 的全称是 Visual Studio Code，是一款开源的、免费的、跨平台的、高性能的、轻量级的代码编辑器。它在性能、语言支持、开源社区方面，都做得很不错。 微软有两种软件：一种是 VS Code，一种是其他软件。 IDE 与 编辑器的对比IDE 和编辑器是有区别的： IDE（Integrated Development Environment，集成开发环境）：对代码有较好的智能提示和相互跳转，同时侧重于工程项目，对项目的开发、调试工作有较好的图像化界面的支持，因此比较笨重。比如 Eclipse 的定位就是 IDE。 编辑器：要相对轻量许多，侧重于文本的编辑。比如 Sublime Text 的定位就是编辑器。再比如 Windows 系统自带的「记事本」就是最简单的编辑器。 需要注意的是，VS Code 的定位是编辑器，而非 IDE ，但 VS Code 又比一般的编辑器的功能要丰富许多。可以这样理解：VS Code 的体量是介于编辑器和 IDE 之间。 VS Code 的特点 VS Code 的使命，是让开发者在编辑器里拥有 IDE 那样的开发体验，比如代码的智能提示、语法检查、图形化的调试工具、插件扩展、版本管理等。 跨平台支持 MacOS、Windows 和 Linux 等多个平台。 VS Code 的源代码以 MIT 协议开源。 支持第三方插件，功能强大，生态系统完善。 VS Code 自带了 JavaScript、TypeScript 和 Node.js 的支持。也就是说，你在书写 JS 和 TS 时，是自带智能提示的。当然，其他的语言，你可以安装相应的扩展包插件，也会有智能提示。 前端利器之争： VS Code 与 WebStorm前端小白最喜欢问的一个问题是：哪个编辑器/IDE 好用？是 VS Code 还是 WebStorm （WebStorm 其实是 IntelliJ IDEA 的定制版）？我来做个对比： 哪个更酷：显然 VS Code 更酷。 内存占用情况：根据我的观察，VS Code 是很占内存的（尤其是当你打开多个窗口的时候），但如果你的内存条够用，使用起来是不会有任何卡顿的感觉的。相比之下，IntelliJ IDEA 不仅非常占内存，而且还非常卡顿。如果你想换个既轻量级、又不占内存的编辑器，最好还是使用「Sublime Text」编辑器。 使用比例：当然是 VS Code 更胜一筹。先不说别的，我就拿数据说话，我目前所在的研发团队有 200 人左右（120个后台、80个前端），他们绝大部分人都在用 VS Code 编码，妥妥的。 所以，如果你以后还问这个问题，那就真有些掉底了。 VS Code 的安装 VS Code 官网：https://code.visualstudio.com VS Code 的安装很简单，直接去官网下载安装包，然后双击安装即可。 上图中，直接点击 download，一键下载安装即可。 二、崭露锋芒：VS Code 快捷键VS Code 用得熟不熟，首先就看你是否会用快捷键。以下列出的内容，都是常用快捷键，而加粗部分的快捷键，使用频率则非常高。 任何工具，掌握 20%的技能，足矣应对 80% 的工作。既然如此，你可能会问：那就只保留 20% 的特性，不久可以满足 80%的用户了吗？ 但我想说的是：那从来都不是同样的 20%，每个人都会用到不同的功能。 掌握下面这些高频核心快捷键，你和你的工具，足矣露出锋芒。 1、工作区快捷键 Mac 快捷键 Win 快捷键 作用 备注 Cmd + Shift + P Ctrl + Shift + P，F1 显示命令面板 Cmd + B Ctrl + B 显示/隐藏侧边栏 很实用 Cmd + \ Ctrl + \ 创建多个编辑器 【重要】抄代码利器 Cmd + 1、2 Ctrl + 1、2 聚焦到第 1、第 2 个编辑器 同上重要 cmd +/- ctrl +/- 将工作区放大/缩小（包括代码字体、左侧导航栏） 在投影仪场景经常用到 Cmd + J Ctrl + J 显示/隐藏控制台 Cmd + Shift + N Ctrl + Shift + N 重新开一个软件的窗口 很常用 Cmd + Shift + W Ctrl + Shift + W 关闭软件的当前窗口 Cmd + N Ctrl + N 新建文件 Cmd + W Ctrl + W 关闭当前文件 2、跳转操作 Mac 快捷键 Win 快捷键 作用 备注 Cmd + ` 没有 在同一个软件的多个工作区之间切换 使用很频繁 Cmd + Option + 左右方向键 Ctrl + Pagedown/Pageup 在已经打开的多个文件之间进行切换 非常实用 Ctrl + Tab Ctrl + Tab 在已经打开的多个文件之间进行跳转 不如上面的快捷键快 Cmd + Shift + O Ctrl + shift + O 在当前文件的各种方法之间进行跳转 Ctrl + G Ctrl + G 跳转到指定行 Cmd+Shift+\ Ctrl+Shift+\ 跳转到匹配的括号 3、移动光标 Mac 快捷键 Win 快捷键 作用 备注 方向键 方向键 在单个字符之间移动光标 大家都知道 option + 左右方向键 Ctrl + 左右方向键 在单词之间移动光标 很常用 Cmd + 左右方向键 Fn + 左右方向键 在整行之间移动光标 很常用 Cmd + ← Fn + ←（或 Win + ←） 将光标定位到当前行的最左侧 很常用 Cmd + → Fn + →（或 Win + →） 将光标定位到当前行的最右侧 很常用 Cmd + ↑ Ctrl + Home 将光标定位到文章的第一行 Cmd + ↓ Ctrl + End 将光标定位到文章的最后一行 Cmd + Shift + \ 在代码块之间移动光标 4、编辑操作 Mac 快捷键 Win 快捷键 作用 备注 Cmd + Enter Ctrl + Enter 在当前行的下方新增一行，然后跳至该行 即使光标不在行尾，也能快速向下插入一行 Cmd+Shift+Enter Ctrl+Shift+Enter 在当前行的上方新增一行，然后跳至该行 即使光标不在行尾，也能快速向上插入一行 Option + ↑ Alt + ↑ 将代码向上移动 很常用 Option + ↓ Alt + ↓ 将代码向下移动 很常用 Option + Shift + ↑ Alt + Shift + ↑ 将代码向上复制 Option + Shift + ↓ Alt + Shift + ↓ 将代码向下复制 写重复代码的利器 5、多光标编辑 Mac 快捷键 Win 快捷键 作用 备注 Cmd + Option + 上下键 Ctrl + Alt + 上下键 在连续的多列上，同时出现光标 Option + 鼠标点击任意位置 Alt + 鼠标点击任意位置 在任意位置，同时出现光标 Option + Shift + 鼠标拖动 Alt + Shift + 鼠标拖动 在选中区域的每一行末尾，出现光标 Cmd + Shift + L Ctrl + Shift + L 在选中文本的所有相同内容处，出现光标 其他的多光标编辑操作：（很重要） 选中某个文本，然后反复按住快捷键「 Cmd + D 」键（windows 用户是按住「Ctrl + D」键）， 即可将全文中相同的词逐一加入选择。 选中一堆文本后，按住「Option + Shift + i」键（windows 用户是按住「Alt + Shift + I」键），既可在每一行的末尾都创建一个光标。 6、删除操作 Mac 快捷键 Win 快捷键 作用 备注 Cmd + shift + K Ctrl + Shift + K 删除整行 「Cmd + X」的作用是剪切，但也可以删除整行 option + Backspace Ctrl + Backspace 删除光标之前的一个单词 英文有效，很常用 option + delete Ctrl + delete 删除光标之后的一个单词 Cmd + Backspace 删除光标之前的整行内容 很常用 Cmd + delete 删除光标之后的整行内容 备注：上面所讲到的移动光标、编辑操作、删除操作的快捷键，在其他编辑器里，大部分都适用。 7、编程语言相关 Mac 快捷键 Win 快捷键 作用 备注 Cmd + / Ctrl + / 添加单行注释 很常用 Option + Shift + F Alt + shift + F 代码格式化 很常用 F2 F2 以重构的方式进行重命名 改代码备 Ctrl + J 将多行代码合并为一行 Win 用户可在命令面板搜索”合并行“ Cmd + Cmd + U Ctrl + U 将光标的移动回退到上一个位置 撤销光标的移动和选择 8、搜索相关 Mac 快捷键 Win 快捷键 作用 备注 Cmd + Shift + F Ctrl + Shift +F 全局搜索代码 很常用 Cmd + P Ctrl + P 在当前的项目工程里，全局搜索文件名 Cmd + F Ctrl + F 在当前文件中搜索代码，光标在搜索框里 Cmd + G F3 在当前文件中搜索代码，光标仍停留在编辑器里 很巧妙 9、自定义快捷键按住快捷键「Cmd + Shift + P」，弹出命令面板，在命令面板中输入“快捷键”，可以进入快捷键的设置。 当然，你也可以选择菜单栏「偏好设置 —&gt; 键盘快捷方式」，进入快捷键的设置： 10、快捷键列表你可以点击 VS Code 左下角的齿轮按钮，效果如下： 上图中，在展开的菜单中选择「键盘快捷方式」，就可以查看和修改所有的快捷键列表了： 快捷键参考链接 快捷键速查表[官方]：https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf 三、命令面板的使用Mac 用户按住快捷键 Cmd+Shift+P （Windows 用户按住快捷键Ctrl+Shift+P），可以打开命令面板。效果如下： 如果们需要修改一些设置项，可以通过「命令面板」来操作，效率会更高。这里列举一些。 1、设置字体大小在命令面板输入“字体”，可以进行字体的设置，效果如下： 当然，你也可以在菜单栏，选择「首选项-设置-常用设置」，在这个设置项里修改字体大小。 2、快捷键设置在命令面板输入“快捷键”，就可以进入快捷键的设置。 3、大小写转换选中文本后，在命令面板中输入transfrom，就可以修改文本的大小写了。 4、使用命令行启动 VS Code（1）输入快捷键「Cmd + Shift + P 」，选择install code command： （2）使用命令行： code命令：启动 VS Code 软件 code pathName/fileName命令：通过 VS Code 软件打开指定目录/指定文件。 四、私人订制：VS Code 的常见配置1、VS Code 设置为中文语言Mac 用户按住快捷键 Cmd+Shift+P （Windows 用户按住快捷键Ctrl+Shift+P），打开命令面板。 在命令面板中，输入Configure Display Language，选择Install additional languages，然后安装插件Chinese (Simplified) Language Pack for Visual Studio Code即可。 或者，我们可以直接安装插件Chinese (Simplified) Language Pack for Visual Studio Code，是一样的。 安装完成后，重启 VS Code。 2、面包屑（Breadcrumb）打开 VS Code 的设置项，选择「用户设置 -&gt; 工作台 -&gt; 导航路径」，如下图所示： 上图中，将红框部分打钩即可。 设置成功后，我们就可以查看到当前文件的「层级结构」，非常方便。如下图所示： 有了这个面包屑导航，我们可以在任意目录、任意文件之间随意跳转。 3、左右显示多个编辑器窗口（抄代码利器）Mac 用户按住快捷键 Cmd + \， Windows 用户按住快捷键Ctrl + \，即可同时打开多个编辑器窗口，效果如下： 按快捷键「Cmd + 1 」切换到左边的窗口，按快捷键「Cmd + 2 」切换到右边的窗口。随时随地，想切就切。 学会了这一招，以后抄代码的时候，leader 再也不用担心我抄得慢了，一天工资到手。 4、是否显示代码的行号VS Code 默认显示代码的行号。你可以在设置项里搜索 editor.lineNumbers修改设置，配置项如下： 我建议保留这个设置项，无需修改。 5、右侧是否显示代码的缩略图VS Code 会在代码的右侧，默认显示缩略图。你可以在设置项里搜索 editor.minimap进行设置，配置项如下： 6、将当前行代码高亮显示（更改光标所在行的背景色）当我们把光标放在某一行时，这一行的背景色并没有发生变化。如果想高亮显示当前行的代码，需要设置两步： （1）在设置项里搜索editor.renderLineHighlight，将选项值设置为all或者line。 （2）在设置项里增加如下内容： 1234"workbench.colorCustomizations": &#123; "editor.lineHighlightBackground": "#00000090", "editor.lineHighlightBorder": "#ffffff30"&#125; 上方代码，第一行代码的意思是：修改光标所在行的背景色（背景色设置为全黑，不透明度 90%）；第二行代码的意思是：修改光标所在行的边框色。 7、改完代码后立即自动保存方式一： 改完代码后，默认不会自动保存。你可以在设置项里搜索files.autoSave，修改配置项如下： 上图中，我们将配置项修改为onFocusChange之后，那么，当光标离开该文件后，这个文件就会自动保存了。非常方便。 方式二： 当然，你也可以直接在菜单栏选择「文件-自动保存」。勾选后，当你写完代码后，文件会立即实时保存。 8、保存代码后，是否立即格式化保存代码后，默认不会立即进行代码的格式化。你可以在设置项里搜索editor.formatOnSave查看该配置项： 我觉得这个配置项保持默认就好，不用打钩。 9、空格 or 制表符VS Code 会根据你所打开的文件来决定该使用空格还是制表。也就是说，如果你的项目中使用的都是制表符，那么，当你在写新的代码时，按下 tab 键后，编辑器就会识别成制表符。 常见的设置项如下： editor.detectIndentation：自动检测（默认开启）。截图如下： editor.insertSpaces：按 Tab 键时插入空格（默认）。截图如下： editor.tabSize：一个制表符默认等于四个空格。截图如下： 10、新建文件后的默认文件类型当我们按下快捷键「Cmd + N」新建文件时，VS Code 默认无法识别这个文件到底是什么类型的，因此也就无法识别相应的语法高亮。 如果你想修改默认的文件类型，可以在设置项里搜索files.defaultLanguage，设置项如下： 上图中的红框部分，填入你期望的默认文件类型。我填的是html类型，你也可以填写成 javascript 或者 markdown，或者其他的语言类型。 11、删除文件时，是否弹出确认框当我们在 VS Code 中删除文件时，默认会弹出确认框。如果你想修改设置，可以在设置项里搜索xplorer.confirmDelete。截图如下： 我建议这个设置项保持默认的打钩就好，不用修改。删除文件前的弹窗提示，也是为了安全考虑，万一手贱不小心删了呢？ 接下来，我们来讲一些更高级的配置。 12、文件对比VS Code 默认支持对比两个文件的内容。选中两个文件，然后右键选择「将已选项进行比较」即可，效果如下： VS Code 自带的对比功能并不够强大，我们可以安装插件compareit，进行更丰富的对比。比如说，安装完插件compareit之后，我们可以将「当前文件」与「剪切板」里的内容进行对比： 13、查找某个函数在哪些地方被调用了比如我已经在a.js文件里调用了 foo()函数。那么，如果我想知道foo()函数在其他文件中是否也被调用了，该怎么做呢？ 做法如下：在 a.js 文件里，选中foo()函数（或者将光标放置在foo()函数上），然后按住快捷键「Shift + F12」，就能看到 foo()函数在哪些地方被调用了，比较实用。 14、鼠标操作 在当前行的位置，鼠标三击，可以选中当前行。 用鼠标单击文件的行号，可以选中当前行。 在某个行号的位置，上下移动鼠标，可以选中多行。 15、重构重构分很多种，我们来举几个例子。 命名重构： 当我们尝试去修改某个函数（或者变量名）时，我们可以把光标放在上面，然后按下「F2」键，那么，这个函数（或者变量名）出现的地方都会被修改。 方法重构： 选中某一段代码，这个时候，代码的左侧会出现一个「灯泡图标」，点击这个图标，就可以把这段代码提取为一个单独的函数。 16、在当前文件中搜索在上面的快捷键列表中，我们已经知道如下快捷键： Cmd + F（Win 用户是 Ctrl + F）：在当前文件中搜索，光标在搜索框里 Cmd + G（Win 用户是 F3）：在当前文件中搜索，光标仍停留在编辑器里 另外，你可能会注意到，搜索框里有很多按钮，每个按钮都对应着不同的功能，如下图所示： 上图中，你可以通过「Tab」键和「Shift + Tab」键在输入框和替换框之间进行切换。 「在选定内容中查找」这个功能还是比较实用的。你也可以在设置项里搜索 editor.find.autoFindInSelection，勾选该设置项后，那么，当你选中指定内容后，然后按住「Cmd + F」，就可以自动只在这些内容里进行查找。该设置项如下图所示： 17、全局搜索在上面的快捷键列表中，我们已经知道如下快捷键： Cmd + Shift + F（Win 用户是 Ctrl + Shift +F）：在全局的文件夹中进行搜索。效果如下： 上图中，你可以点击红框部分，展开更多的配置项。 18、Git 版本管理VS Code 自带了 Git 版本管理，如下图所示： 上图中，我们可以在这里进行常见的 git 命令操作。如果你还不熟悉 Git 版本管理，可以先去补补课。 与此同时，我建议安装插件GitLens，它是 VS Code 中我最推荐的一个插件，简直是 Git 神器，码农必备。 19、将工作区放大/缩小我们在上面的设置项里修改字体大小后，仅仅只是修改了代码的字体大小。 如果你想要缩放整个工作区（包括代码的字体、左侧导航栏的字体等），可以按下快捷键「cmd +/-」。windows 用户是按下「ctrl +/-」 当我们在投影仪上给别人演示代码的时候，这一招十分管用。 如果你想恢复默认的工作区大小，可以在命令面板输入重置缩放（英文是reset zoom） 20、创建多层子文件夹我们可以在新建文件夹的时候，如果直接输入aa/bb/cc，比如： 那么，就可以创建多层子文件夹，效果如下： 21、.vscode 文件夹的作用为了统一团队的 vscode 配置，我们可以在项目的根目录下建立.vscode目录，在里面放置一些配置内容，比如： settings.json：工作空间设置、代码格式化配置、插件配置。 sftp.json：ftp 文件传输的配置。 .vscode目录里的配置只针对当前项目范围内生效。将.vscode提交到代码仓库，大家统一配置时，会非常方便。 22、自带终端我们可以按下「Ctrl + `」打开 VS Code 自带的终端。我认为内置终端并没有那么好用，我更建议你使用第三方的终端 item2。 23、markdown 语法支持VS Code 自带 markdown 语法高亮。也就是说，如果你是用 markdown 格式写文章，则完全可以用 VS Code 进行写作。 写完 md 文件之后，你可以点击右上角的按钮进行预览，如下图所示： 我一般是安装「Markdown Preview Github Styling」插件，以 GitHub 风格预览 Markdown 样式。样式十分简洁美观。 你也可以在控制面板输入Markdown: 打开预览，直接全屏预览 markdown 文件。 24、Emmet in VS CodeEmmet可以极大的提高 html 和 css 的编写效率，它提供了一种非常简练的语法规则。 举个例子，我们在编辑器中输入缩写代码：ul&gt;li*6 ，然后按下 Tab 键，即可得到如下代码片段： 12345678&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; VS Code 默认支持 Emmet。更多 Emmet 语法规则，请自行查阅。 25、修改字体，使用「Fira Code」字体这款字体很漂亮，很适合用来写代码： 安装步骤如下： （1）进入 https://github.com/tonsky/FiraCode 网站，下载并安装「Fira Code」字体。 （2）打开 VS Code 的「设置」，搜索font，修改相关配置为如下内容： 12"editor.fontFamily": "'Fira Code',Menlo, Monaco, 'Courier New', monospace", // 设置字体显示"editor.fontLigatures": false,//控制是否启用字体连字，true启用，false不启用 上方的第二行配置，取决于个人习惯，我是直接设置为&quot;editor.fontLigatures&quot;: null，因为我不太习惯连字。 26、代码格式化：Prettier我们可以使用 Prettier进行代码格式化，会让代码的展示更加美观。步骤如下： （1）安装插件 Prettier。 （2）在项目的根路径下，新建文件.prettierrc，并在文件中添加如下内容： 123456789&#123; "printWidth": 150, "tabWidth": 4, "semi": true, "singleQuote": true, "trailingComma": "es5", "tslintIntegration": true, "insertSpaceBeforeFunctionParenthesis": false&#125; 上面的内容，是我自己的配置，你可以参考。 更多配置，可以参考官方文档：https://prettier.io/docs/en/options.html 27、文件传输：sftp如果你需要将本地文件通过 ftp 的形式上传到局域网的服务器，可以安装sftp这个插件，很好用。在公司会经常用到。 步骤如下： （1）安装插件sftp。 （2）配置 sftp.json文件。 插件安装完成后，输入快捷键「cmd+shift+P」弹出命令面板，然后输入sftp:config，回车，当前工程的.vscode文件夹下就会自动生成一个sftp.json文件，我们需要在这个文件里配置的内容可以是： host：服务器的 IP 地址 username：用户名 privateKeyPath：存放在本地的已配置好的用于登录工作站的密钥文件（也可以是 ppk 文件） remotePath：工作站上与本地工程同步的文件夹路径，需要和本地工程文件根目录同名，且在使用 sftp 上传文件之前，要手动在工作站上 mkdir 生成这个根目录 ignore：指定在使用 sftp: sync to remote 的时候忽略的文件及文件夹，注意每一行后面有逗号，最后一行没有逗号 举例如下：(注意，其中的注释需要去掉) 1234567891011121314151617181920212223242526272829&#123; "host": "192.168.xxx.xxx", //服务器ip "port": 22, //端口，sftp模式是22 "username": "", //用户名 "password": "", //密码 "protocol": "sftp", //模式 "agent": null, "privateKeyPath": null, "passphrase": null, "passive": false, "interactiveAuth": false, "remotePath": "/root/node/build/", //服务器上的文件地址 "context": "./server/build", //本地的文件地址 "uploadOnSave": true, //监听保存并上传 "syncMode": "update", "watcher": &#123; //监听外部文件 "files": false, //外部文件的绝对路径 "autoUpload": false, "autoDelete": false &#125;, "ignore": [ //忽略项 "**/.vscode/**", "**/.git/**", "**/.DS_Store" ]&#125; （3）在 VS Code 的当前文件里，选择「右键 -&gt; upload」，就可以将本地的代码上传到 指定的 ftp 服务器上（也就是在上方 host 中配置的服务器 ip）。 我们还可以选择「右键 -&gt; Diff with Remote」，就可以将本地的代码和 ftp 服务器上的代码做对比。 七、VS Code 配置云同步我们可以将配置云同步，这样的话，当我们换个电脑时，即可将配置一键同步到本地，就不需要重新安装插件了，也不需要重新配置软件。 我们还可以把配置分享其他用户，也可以把其他用户的配置给自己用。 将自己本地的配置云同步到 GitHub： （1）安装插件 settings-sync。 （2）安装完插件后，在插件里使用 GitHub 账号登录。 （3）登录后在 vscode 的界面中，可以选择一个别人的 gist；也可以忽略掉，然后创建一个属于自己的 gist。 （4）使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「更新/上传配置」，这样就可以把最新的配置上传到 GitHub。 换另外一个电脑时，从云端同步配置到本地： （1）当我们换另外一台电脑时，可以先在 VS Code 中安装 settings-sync 插件。 （2）安装完插件后，在插件里使用 GitHub 账号登录。 （3）登录之后，插件的界面上，会自动出现之前的同步记录： 上图中，我们点击最新的那条记录，就可将云端的最新配置同步到本地： 如果你远程的配置没有成功同步到本地，那可能是网络的问题，此时，可以使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「下载配置」，多试几次。 使用其他人的配置： 如果我们想使用别人的配置，首先需要对方提供给你 gist。具体步骤如下： （1）安装插件 settings-sync。 （2）使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「下载配置」 （3）在弹出的界面中，选择「Download Public Gist」，然后输入别人分享给你的 gist。注意，这一步不需要登录 GitHub 账号。 八、三头六臂：VS Code 插件推荐VS Code 有一个很强大的功能就是支持插件扩展，让你的编辑器仿佛拥有了三头六臂。 上图中，点击红框部分，即可在输入框里，查找你想要的插件名，然后进行安装。 我来列举几个常见的插件，这些插件都很实用。注意：顺序越靠前，越实用。 1、GitLens 【荐】我强烈建议你安装插件GitLens，它是 VS Code 中我最推荐的一个插件，简直是 Git 神器，码农必备。如果你不知道，那真是 out 了。 GitLens 在 Git 管理上有很多强大的功能，比如： 将光标放置在代码的当前行，可以看到这样代码的提交者是谁，以及提交时间。这一点，是 GitLens 最便捷的功能。 查看某个 commit 的代码改动记录 查看不同的分支 可以将两个 commit 进行代码对比 甚至可以将两个 branch 分支进行整体的代码对比。这一点，简直是 GitLens 最强大的功能。当我们在不同分支 review 代码的时候，就可以用到这一招。 2、Git History有些同学习惯使用编辑器中的 Git 管理工具，而不太喜欢要打开另外一个 Git UI 工具的同学，这一款插件满足你查询所有 Git 记录的需求。 3、Live Server 【荐】在本地启动一个服务器，代码写完后可以实现「热更新」，实时地在网页中看到运行效果。就不需要每次都得手动刷新页面了。 使用方式：安装插件后，开始写代码；代码写完后，右键选择「Open with Live Server」。 4、Chinese (Simplified) Language Pack for Visual Studio Code让软件显示为简体中文语言。 5、Bracket Pair Colorizer 2：突出显示成对的括号【荐】Bracket Pair Colorizer 2插件：以不同颜色显示成对的括号，并用连线标注括号范围。简称彩虹括号。 另外，还有个Rainbow Brackets插件，也可以突出显示成对的括号。 6、sftp：文件传输 【荐】如果你需要将本地文件通过 ftp 的形式上传到局域网的服务器，可以安装sftp这个插件，很好用。在公司会经常用到。 详细配置已经在上面讲过。 7、open in browser安装open in browser插件后，在 HTML 文件中「右键选择 —&gt; Open in Default Browser」，即可在浏览器中预览网页。 8、highlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】VSCode 自带的高亮显示，实在是不够显眼。用插件支持一下吧。 所用了这个插件之后，VS Code 自带的高亮就可以关掉了： 在用户设置里添加&quot;editor.selectionHighlight&quot;: false即可。 参考链接：vscode 选中后相同内容高亮插件推荐 9、vscode-iconsvscode-icons 会根据文件的后缀名来显示不同的图标，让你更直观地知道每种文件是什么类型的。 10、Project Manager工作中，我们经常会来回切换多个项目，每次都要找到对应项目的目录再打开，比较麻烦。Project Manager 插件可以解决这样的烦恼，它提供了专门的视图来展示你的项目，我们可以把常用的项目保存在这里，需要时一键切换，十分方便。 11、TODO Highlight写代码过程中，突然发现一个 Bug，但是又不想停下来手中的活，以免打断思路，怎么办？按照代码规范，我们一般是在代码中加个 TODO 注释。比如：（注意，一定要写成大写TODO，而不是小写的todo） 1//TODO:这里有个bug，我一会儿再收拾你 或者： 1//FIXME:我也不知道为啥， but it works only that way. 安装了插件 TODO Highlight之后，按住「Cmd + Shift + P」打开命令面板，输入「Todohighlist」，选择相关的命令，我们就可以看到一个 todoList 的清单。 12、WakaTime 【荐】统计在 VS Code 里写代码的时间。统计效果如下： 13、Code TimeCode Time插件：记录编程时间，统计代码行数。 安装该插件后，VS Code 底部的状态栏右下角可以看到时间统计。点击那个位置之后，选择「Code Time Dashboard」，即可查看统计结果。 备注：团长试了一下这个 code time 插件，发现统计结果不是很准。 14、Markdown Preview Github Styling 【荐】以 GitHub 风格预览 Markdown 样式，十分简洁优雅。就像下面这样，左侧书写 Markdown 文本，右侧预览 Markdown 的渲染效果： 15、Markdown Preview Enhanced预览 Markdown 样式。 Markdown All in One这个插件将帮助你更高效地在 Markdown 中编写文档。 16、Settings Sync【荐】 地址：https://github.com/shanalikhan/code-settings-sync 作用：多台设备之间，同步 VS Code 配置。通过登录 GitHub 账号来使用这个同步工具。 同步的详细操作已在上面讲过。 17、vscode-syncing 地址：https://github.com/nonoroazoro/vscode-syncing 作用：多台设备之间，同步 VS Code 配置。 18、VeturVue 多功能集成插件，包括：语法高亮，智能提示，emmet，错误提示，格式化，自动补全，debugger。VS Code 官方钦定 Vue 插件，Vue 开发者必备。 19、ES7 React/Redux/GraphQL/React-Native snippetsReact/Redux/react-router 的语法智能提示。 20、minapp：小程序支持小程序开发必备插件。 21、Prettier：代码格式化Prettier 是一个代码格式化工具，只关注格式化，但不具备校验功能。在一个多人协同开发的团队中，统一的代码编写规范非常重要。一套规范可以让我们编写的代码达到一致的风格，提高代码的可读性和统一性。自然维护性也会有所提高。 22、ESLint：代码格式校验日常开发中，建议用可以用 Prettier 做代码格式化，然后用 eslint 做校验。 23、Beautify代码格式化工具。 备注：相比之下，Prettier 是当前最流行的代码格式化工具，比 Beautify 用得更多。 24、JavaScript(ES6) code snippetsES6 语法智能提示，支持快速输入。 25、Search node_modules 【荐】node_modules模块里面的文件夹和模块实在是太多了，根本不好找。好在安装 Search node_modules 这个插件后，输入快捷键「Cmd + Shift + P」，然后输入 node_modules，在弹出的选项中选择 Search node_modules，即可搜索 node_modules 里的模块。 26、indent-rainbow：突出显示代码缩进indent-rainbow插件：突出显示代码缩进。 安装完成后，效果如下图所示： 27、javascript console utils：快速打印 log 日志【荐】安装这个插件后，当我们按住快捷键「Cmd + Shift + L」后，即可自动出现日志 console.log()。简直是日志党福音。 当我们选中某个变量 name，然后按住快捷键「Cmd + Shift + L」，即可自动出现这个变量的日志 console.log(name)。 其他的同类插件还有：Turbo Console Log。 不过，生产环境的代码，还是尽量少打日志比较好，避免出现一些异常。 编程有三等境界： 第三等境界是打日志，这是最简单、便捷的方式，略显低级，一般新手或资深程序员偷懒时会用。 第二等境界是断点调试，在前端、Java、PHP、iOS 开发时非常常用，通过断点调试可以很直观地跟踪代码执行逻辑、调用栈、变量等，是非常实用的技巧。 第一等境界是测试驱动开发，在写代码之前先写测试。与第二等的断点调试刚好相反，大部分人不是很习惯这种方式，但在国外开发者或者敏捷爱好者看来，这是最高效的开发方式，在保证代码质量、重构等方面非常有帮助，是现代编程开发必不可少的一部分。 28、Code Spell Checker：单词拼写错误检查这个拼写检查程序的目标是帮助捕获常见的单词拼写错误，可以检测驼峰命名。从此告别 Chinglish. 29、Local History 【荐】维护文件的本地历史记录，强烈建议安装。代码意外丢失时，有时可以救命。 30、Polacode-2020：生成代码截图 【荐】可以把代码片段保存成美观的图片，主题不同，代码的配色方案也不同，也也可以自定义设置图片的边框颜色、大小、阴影。 尤其是在我们做 PPT 分享时需要用到代码片段时，或者需要在网络上优雅地分享代码片段时，这一招很有用。 生成的效果如下： 其他同类插件：CodeSnap。我们也可以通过 https://carbon.now.sh/这个网站生成代码图片 有人可能会说：直接用 QQ 截图不行吗？可以是可以，但不够美观、不够干净。 31、Image Preview 【荐】图片预览。鼠标移动到图片 url 上的时候，会自动显示图片的预览和图片尺寸。 32、Auto Close Tag、Auto Rename Tag自动闭合标签、自动对标签重命名。 33、Better Comments为注释添加更醒目、带分类的色彩。 34、CSS Peek增强 HTML 和 CSS 之间的关联，快速查看该元素上的 CSS 样式。 35、Vue CSS PeekCSS Peek 对 Vue 没有支持，该插件提供了对 Vue 文件的支持。 36、Color Info这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了。 37、RemoteHub不要惊讶，RemoteHub 和 GitLens 是同一个作者开发出来的。 RemoteHub插件的作用是：可以在本地查看 GitHub 网站上的代码，而不需要将代码下载到本地。 这个插件目前使用的人还不多，赶紧安装起来尝尝鲜吧。 38、Live Share：实时编码分享Live Share这个神奇的插件是由微软官方出品，它的作用是：实时编码分享。也就是说，它可以实现你和你的同伴一起写代码。这绝对就是结对编程的神器啊。 安装方式： 打开插件管理，搜索“live share”，安装。安装后重启 VS Code，在左侧会多出一个按钮： 上图中，点击红框部分，登录后就可以分享你的工作空间了。 39、Import Cost在项目开发过程中，我们会引入很多 npm 包，有时候可能只用到了某个包里的一个方法，却引入了整个包，导致代码体积增大很多。Import Cost插件可以在代码中友好的提示我们，当前引入的包会增加多少体积，这很有助于帮我们优化代码的体积。 Paste JSON as Code此插件可以将剪贴板中的 JSON 字符串转换成工作代码。支持多种语言。 八、常见主题插件给你的 VS Code 换个皮肤吧，免费的那种。 Dracula Theme Material Theme Nebula Theme One Dark Pro One Monokai Theme Monokai Pro Ayu Snazzy Plus Dainty SynthWave &#39;84 GitHub Plus Theme：白色主题 Horizon Theme：红色主题]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化格式化文件夹名字使用说明]]></title>
    <url>%2Fhomework_change.html</url>
    <content type="text"><![CDATA[步骤说明(对应图上标签) 首先，选择包含学号、姓名信息的Excel文件，Excel里面第一行的列名一定要有学号姓名 读取数据，则可以再左边看到相应数据 选择你要修改文件名的文件夹(必填) 输入你们学号的前四位(必填) 填写文件主要名称(选填) 比如填写的是： 实验报告1 就是 学号-姓名-实验报告1 选择组成方式 选择学号姓名文件名称的连接方式 开始修改 如果开启了检测未交那这里会统计有多少人未交 这里会显示学号错误的同学 如果使用中发现相应Bug，欢迎在下方评论]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas如何基于某一列的数据对其它列进行操作]]></title>
    <url>%2Fpandas%20operate.html</url>
    <content type="text"><![CDATA[我们就简单举一个例子 把star_rating为3到4中的positive减去0.25 把star_rating小于3的positive减去0.3 star_rating positive 0 5 0.98072 1 1 0.737101 2 5 0.945672 3 2 0.729632 4 5 0.99853 5 3 0.408589 6 1 0.650988 7 1 0.666691 8 5 0.899953 9 4 0.895248 10 4 0.609864 11 3 0.614354 12 4 0.892443 13 3 0.648455 14 4 0.880974 15 5 0.998756 16 3 0.046396 17 4 0.882441 18 1 0.509702 19 5 0.959157 20 1 0.640282 这里提供多种方法有麻烦有简单： 法一（利用切片）： 12dff.loc[(3 &lt;= dff["star_rating"])&amp;(dff["star_rating"] &lt;= 4),"positive"] = dff.loc[(3 &lt;= dff["star_rating"])&amp;(dff["star_rating"] &lt;= 4),"positive"].apply(lambda x:np.abs(x-0.25))dff.loc[(0 &lt;= dff["star_rating"])&amp;(dff["star_rating"] &lt; 3),"positive"] = dff.loc[(0 &lt;= dff["star_rating"])&amp;(dff["star_rating"] &lt; 3),"positive"].apply(lambda x:np.abs(x-0.3)) 法二（利用apply + lambda）： 1234567def to_cal(x,y): if 3 &lt;=x &lt;=4: y -= 0.25 elif 1 &lt;= x &lt; 3: y -= 0.2 return y dff.apply(lambda row:to_cal(row["star_rating"],row["positive"]),axis = 1) 法三 （切片 + apply) 12345678def fun(a): if a['star_rating'] &lt;= 3: a.loc["positive"] = a.loc["positive"] - 0.3 elif a['star_rating'] &gt;3 and a['star_rating'] &lt;= 4: a.loc['positive'] = a.loc['positive'] - 0.25 return adata = dff.loc[:].apply(fun,axis = 1) 以上提供了3种解决思路，如果在看的大佬们还有更好的思路欢迎提出来哦]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性筛的两种方法]]></title>
    <url>%2FjudgePrime.html</url>
    <content type="text"><![CDATA[埃氏筛法 O(n*log(logn))123456789101112131415is_prime = [0 for _ in range(1001)] # 初始化列表def Prime(): for i in range(2, 1001): if is_prime[i] == 0: # 第一次未被标记，说明为素数 for j in range(i + i, 1001, i): is_prime[j] = 1 # 素数的倍数为素数，所以标记为1if __name__ == '__main__': Prime() for i in range(2, 1001): # 遍历数组，如果被标记为0的则输出 if is_prime[i] == 0: print(i, end=" ") 欧拉筛 线性O(n)复杂度12345678910111213flag = [0 for _ in range(105)]a = []for i in range(2, 101): if flag[i] == 0: a.append(i) # 判断是否为素数 j = 0 while i * a[j] &lt;= 100: flag[a[j] * i] = 1 # 筛选 if i % a[j] == 0: # 关键优化！ break j += 1print(a)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM，判断素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在远程服务器上搭建jupyter]]></title>
    <url>%2Fremote_jupyter_use.html</url>
    <content type="text"><![CDATA[马上就要美赛了嘛，涉及到跑大量数据，处理复杂的模型 这里我就总结一下如何在只有cmd的情况下使用jupyter notebook 1. 安装jupyter服务1pip install jupyter # 最好用pip3 2. 配置远程访问jupyter先输入python3进入交互模式 ，见图输入以下内容，设置好密码过后 会自动生成一个Verify password复制保存下来 退出交互模式 2.1生成配置文件在输入以下内容 1jupyter notebook --generate-config 就会自动在根目录下生成文件（~/.jupyter/jupyter_notebook_config.py），如果看不到，选项中选择显示隐藏文件 2.2修改配置文件建议先把jupyter_notebook_config.py文件传输到本地修改完成再上传 找到以下字符串进行修改 12345c.NotebookApp.ip='*' # 如果这里修过过后启动服务报错 则修改为c.NotebookApp.ip='0.0.0.0'c.NotebookApp.password=u'sha1****' #就之前保存的验证密码c.NotebookApp.open_browser =False # 设置是否自动打开浏览器c.NotebookApp.port =8888 # 设置端口c.NotebookApp.allow_remote_access = True 3. 启动服务这里推荐两种 入门：jupyter notebook --allow-root 但这种会一直占着窗口，无法执行其他命令 Ctrl + C 即可结束 进阶: nohup jupyter notebook --allow-root nohup表示no hang up, 就是不挂起, 于是这个命令执行后即使终端退出, 也不会停止运行. 但要手动结束 lsof -i : {端口号} 然后 kill -9 {对应pid} # 9的意思是发送KILL信号，立刻结束，可能会有数据丢失 启动以后在本机 输入http://{服务器ip}:8888 进行访问 第一次进入要输入之前设置的密码，但为了效率见第4步 若安全组未设置一定要去添加上端口号，设置以上 4. 安装增强功能（自动补全之类）在终端中依次执行以下4行代码 1234pip install jupyter_contrib_nbextensionsjupyter contrib nbextension install --userpip install jupyter_nbextensions_configuratorjupyter nbextensions_configurator enable --user]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性代数图形学习]]></title>
    <url>%2FLinear_algebra_review.html</url>
    <content type="text"><![CDATA[最近老师推荐了一套线代视频，趁热打铁 全套视频视频传送门 需要科学上网噢 关于线性相关？ 产生了新的维度 — 线性无关 没有新的维度产生 — 线性相关 线性变化 基低的变化同时，能保持网格线平行且等距分布，并且保持原点不变 \left[\begin{array}{ll}{a} & {b} \\ {c} & {d}\end{array}\right]\left[\begin{array}{l}{x} \\ {y}\end{array}\right]=x\left[\begin{array}{l}{a} \\ {c}\end{array}\right]+y\left[\begin{array}{l}{b} \\ {d}\end{array}\right]=\left[\begin{array}{l}{a x+b y} \\ {c x+d y}\end{array}\right]So,矩阵就代表一个特定的线性变换,矩阵相乘就是将线性变换作用域那个向量 Never forget what the represent!]]></content>
      <categories>
        <category>机器学习</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy实用API]]></title>
    <url>%2Fnumpy_common.html</url>
    <content type="text"><![CDATA[About​ 最近在数据分析时候发现，原来在numpy里面有许多冷门但很实用的api被我忽视了，特此记录一下 找出两个一维数组中相同的元素 12345678910Z1 = np.random.randint(0, 10, 10)Z2 = np.random.randint(0, 10, 10)print("Z1:", Z1)print("Z2:", Z2)np.intersect1d(Z1, Z2)result:Z1: [2 5 2 4 6 5 9 3 7 4]Z2: [7 4 8 6 2 8 7 3 7 8]array([2, 3, 4, 6, 7]) 使用五种不同的方法去提取一个随机数组的整数部分： 12345678910111213141516171819Z = np.random.uniform(0, 10, 10)print("原始值: ", Z)print(Z % 1)print("方法 1: ", Z - Z % 1)print("方法 2: ", np.floor(Z))print("方法 3: ", np.ceil(Z))print("方法 4: ", Z.astype(int))print("方法 5: ", np.trunc(Z))result:原始值: [2.73346348 7.69828757 7.86482191 1.13211405 3.76974342 3.82244943 8.48062002 0.40903781 9.41422722 3.56932426][0.73346348 0.69828757 0.86482191 0.13211405 0.76974342 0.82244943 0.48062002 0.40903781 0.41422722 0.56932426]方法 1: [2. 7. 7. 1. 3. 3. 8. 0. 9. 3.]方法 2: [2. 7. 7. 1. 3. 3. 8. 0. 9. 3.]方法 3: [ 3. 8. 8. 2. 4. 4. 9. 1. 10. 4.]方法 4: [2 7 7 1 3 3 8 0 9 3]方法 5: [2. 7. 7. 1. 3. 3. 8. 0. 9. 3.] 找出随机一维数组中出现频率最高的值： 12345678910111213Z = np.random.randint(0, 10, 50)print("随机一维数组:", Z)np.bincount(Z).argmax()# 我们可以看到x中最大的数为7，因此bin的数量为8，那么它的索引值为0-&gt;7#x = np.array([0, 1, 1, 3, 2, 1, 7])# 索引0出现了1次，索引1出现了3次......索引5出现了0次......#np.bincount(x)#因此，输出结果为：array([1, 3, 1, 1, 0, 0, 0, 1])result:随机一维数组: [1 7 7 1 1 6 6 2 7 5 4 2 5 2 6 4 8 6 7 0 6 6 1 3 8 1 9 1 4 2 6 2 2 6 4 3 7 0 8 5 3 5 3 6 9 1 7 7 7 7]6 找出给定一维数组中非 0 元素的位置索引： 12345Z = np.nonzero([1, 0, 2, 0, 1, 0, 4, 0])Z result:(array([0, 2, 4, 6]),) 对于二维随机数组中各元素，保留其 2 位小数： 1234567891011121314151617Z = np.random.random((5, 5))print(Z)np.set_printoptions(precision=2)Zresult:[[0.60812241 0.73198034 0.94618522 0.38880087 0.57783975] [0.42269846 0.33792021 0.16684304 0.42144049 0.31045111] [0.1848732 0.00996782 0.92683269 0.80099087 0.14715122] [0.75994662 0.74667598 0.35267901 0.83163863 0.88817273] [0.12484054 0.22858327 0.52090342 0.38798047 0.82170694]]array([[0.61, 0.73, 0.95, 0.39, 0.58], [0.42, 0.34, 0.17, 0.42, 0.31], [0.18, 0.01, 0.93, 0.8 , 0.15], [0.76, 0.75, 0.35, 0.83, 0.89], [0.12, 0.23, 0.52, 0.39, 0.82]]) 使用 NumPy 找出百分位数（25%，50%，75%）： 12345678a = np.arange(15)print(a)np.percentile(a, q=[25, 50, 75])result:[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14]array([ 3.5, 7. , 10.5]) 从随机数组中删除包含缺失值的行： 12345678910111213141516171819202122232425262728293031np.isnan(Z)## result:array([[False, False, False, False, False, True, False, False, False, False], [False, False, False, False, False, False, False, False, False, False], [False, False, False, False, False, False, False, False, False, False], [False, False, False, False, False, True, False, False, False, False], [False, False, False, False, False, False, False, False, False, False], [False, False, True, False, True, False, False, False, False, False], [False, False, False, True, False, False, False, False, False, False], [False, False, False, False, False, False, False, False, False, False], [False, False, False, False, False, False, False, False, False, False], [False, False, False, False, False, False, False, False, False, False]])np.sum(np.isnan(Z),axis = 1) # result:array([1, 0, 0, 1, 0, 2, 1, 0, 0, 0])Z[np.sum(np.isnan(Z), axis=1) == 0]# So 这里我们只需挑选出为0的就行 使用 NumPy 计算变量直接的相关性系数： 1234567891011Z = np.array([ [1, 2, 1, 9, 10, 3, 2, 6, 7], # 特征 A [2, 1, 8, 3, 7, 5, 10, 7, 2], # 特征 B [2, 1, 1, 8, 9, 4, 3, 5, 7]]) # 特征 Cnp.corrcoef(Z)# result:array([[ 1. , -0.05640533, 0.97094584], [-0.05640533, 1. , -0.01315587], [ 0.97094584, -0.01315587, 1. ]]) 使用 NumPy 计算矩阵的特征值和特征向量： 12345678910M = np.matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])w, v = np.linalg.eig(M)# w 对应特征值，v 对应特征向量w, v#result:(array([ 1.61168440e+01, -1.11684397e+00, -9.75918483e-16]), #一个数对应一列 matrix([[-0.23197069, -0.78583024, 0.40824829], [-0.52532209, -0.08675134, -0.81649658], [-0.8186735 , 0.61232756, 0.40824829]])) 使用 NumPy 计算 Ndarray 两相邻元素差值： 123456789101112131415Z = np.random.randint(1, 10, 10)print(Z)# 计算 Z 两相邻元素差值print(np.diff(Z, n=1))# 重复计算 2 次print(np.diff(Z, n=2)) # 重复计算 3 次print(np.diff(Z, n=3))# result:[2 4 8 3 5 2 6 7 6 9][ 2 4 -5 2 -3 4 1 -1 3][ 2 -9 7 -5 7 -3 -2 4][-11 16 -12 12 -10 1 6] 使用 NumPy 将 Ndarray 相邻元素依次累加： 1234567891011Z = np.random.randint(1, 10, 10)print(Z)"""[第一个元素, 第一个元素 + 第二个元素, 第一个元素 + 第二个元素 + 第三个元素, ...]"""np.cumsum(Z)#result:[5 1 8 5 8 4 6 2 9 4]array([ 5, 6, 14, 19, 27, 31, 37, 39, 48, 52]) 使用 NumPy 打印九九乘法表： 123456789101112np.fromfunction(lambda i, j: (i + 1) * (j + 1), (9, 9))#result:array([[ 1., 2., 3., 4., 5., 6., 7., 8., 9.], [ 2., 4., 6., 8., 10., 12., 14., 16., 18.], [ 3., 6., 9., 12., 15., 18., 21., 24., 27.], [ 4., 8., 12., 16., 20., 24., 28., 32., 36.], [ 5., 10., 15., 20., 25., 30., 35., 40., 45.], [ 6., 12., 18., 24., 30., 36., 42., 48., 54.], [ 7., 14., 21., 28., 35., 42., 49., 56., 63.], [ 8., 16., 24., 32., 40., 48., 56., 64., 72.], [ 9., 18., 27., 36., 45., 54., 63., 72., 81.]])]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写KNN与sklearn进行对比]]></title>
    <url>%2Fcompare%20KNN%20with%20sklearn_knn.html</url>
    <content type="text"><![CDATA[KNN算法基本描述 邻近算法，或者说K最近邻(kNN，k-NearestNeighbor)分类算法是数据挖掘分类技术中最简单的方法之一。所谓K最近邻，就是k个最近的邻居的意思，说的是每个样本都可以用它最接近的k个邻居来代表。Cover和Hart在1968年提出了最初的邻近算法。KNN是一种分类(classification)算法，它输入基于实例的学习（instance-based learning），属于懒惰学习（lazy learning）即KNN没有显式的学习过程，也就是说没有训练阶段，数据集事先已有了分类和特征值，待收到新样本后直接进行处理。与急切学习（eager learning）相对应。 算法描述： 1. 计算测试数据与各个训练数据之间的距离 2. 按照距离的递增关系进行排序 3. 选取距离最小的K个点 4. 确定前K个点所在类别的出现频率 5. 返回前K个点中出现频率最高的类别作为测试数据的预测分类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from sklearn.neighbors import KNeighborsClassifierfrom sklearn.model_selection import train_test_splitimport pandas as pdimport numpy as npimport matplotlib.pyplot as plt # 导入相应的packagedef get_dis(x, y): return np.sqrt(np.sum(np.square(x - y))) # 计算欧式距离def CreateData(): group = np.array([[1, 1.1], [1, 1], [0, 0], [0, 0.1]]) labels = ['A', 'A', 'B', 'B'] return group, labels # 返回数据与标签def Classify(group, labels, k, data): # 进行手写预测 group['label'] = labels df = group.copy() tmpxy = df[['x', 'y']].values dis = [get_dis(data, item) for item in tmpxy] df['distance'] = dis df = df.sort_values(by='distance').head(k) # 通过距离排序 return max(df['label'].value_counts(normalize=True).index) #计算频率并返回前几个def to_check(group, labels, data, k): group['label'] = labels df = group.copy() knn = KNeighborsClassifier(n_neighbors=k) knn.fit(df[['x', 'y']].values, df['label'].values) print("sklearn里面的knn的预测值为：", knn.predict(data))if __name__ == '__main__': group, labels = CreateData() group = pd.DataFrame(group, columns=['x', 'y']) op = [0 if i == 'A' else 1 for i in labels] colors = ["blue", "red"] color = [colors[i] for i in op] plt.scatter(group['x'], group['y'], c=color) plt.scatter(0, 0.3, c='g', marker='*') plt.show() res = Classify(group, labels, 3, np.array([0, 0.3])) col = "blue" if res == 'B': col = 'red' plt.scatter(group['x'], group['y'], c=color) plt.scatter(0, 0.3, c=col) plt.show() print("手写出来的预测值为：",res) print("分割线".center(100,'=')) # 和sklearn里面的knn的api进行相应的对比 to_check(group, labels, np.array([[0, 0.3]]), 3) # 验证的结果都是B 大家可以自行搞下 可以看到点位相应的变化，被分为了红色类]]></content>
      <categories>
        <category>机器学习</category>
        <category>分类</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>python</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写PCA基于特征向量(协方差和散度矩阵两种方式实现)]]></title>
    <url>%2F%E6%89%8B%E5%86%99PCA.html</url>
    <content type="text"><![CDATA[手写PCA基于特征向量(协方差和散度矩阵两种方式实现)协方差实现12345678910111213141516171819202122232425262728293031323334from sklearn.datasets import load_irisfrom sklearn.decomposition import PCAimport numpy as npimport matplotlib.pyplot as pltdef PPCA(data, k): res_list = [] n_samples, n_features = data.shape # 提取出数据的维度和特征 data_mean = [np.mean(data[:, i]) for i in range(n_features)] # 计算每列的平均值 scale_data = data - data_mean # 利用numpy里面的func机制进行取均值化 res_list = [scale_data[:, i] for i in range(n_features)] # 将每一列作为一个属性 Cov = np.cov(res_list) # 计算协方差 eig_val, eig_vtc = np.linalg.eig(Cov) # 计算特征值和特征向量 eig_fairs = [(np.abs(eig_val[i]), eig_vtc[:, i]) for i in range(n_features)] eig_fairs.sort(reverse=True) # 按特征值进行排序 特征值越大说明越重要 features = [item[1] for item in eig_fairs[:k]] # 按照降维维度选取特征向量 ans = np.dot(scale_data, np.transpose(features)) # 矩阵相乘 得到降维后的数据 return ansdef ppccaa(X, n): ca = PCA(n_components=n) qq = ca.fit_transform(X) return qqif __name__ == '__main__': X = load_iris().data # 导入鸢尾花(yuan wei hua)数据 res = PPCA(X, 2) # 传入数据和要降的纬度 # 验证 print(res) print("分割线".center(50, "=")) print(ppccaa(X, 1)) 散度矩阵实现12345678910111213141516171819202122232425262728293031from sklearn.datasets import load_irisfrom sklearn.decomposition import PCAimport pandas as pdimport numpy as npimport matplotlib.pyplot as pltdef pca(X, k): n_samples, n_features = X.shape mean = np.array([np.mean(X[:, i]) for i in range(n_features)]) norm_X = X - mean scatter_matrix = np.dot(np.transpose(norm_X), norm_X) # 计算散度矩阵 # 协方差矩阵和散度矩阵关系密切，散度矩阵就是协方差矩阵乘以(总数据量-1) # 因此他们的特征梗和特征向量是一样的 eig_val, eig_vec = np.linalg.eig(scatter_matrix) eig_pairs = [(np.abs(eig_val[i]), eig_vec[:, i]) for i in range(n_features)] eig_pairs.sort(reverse=True) feature = np.array([ele[1] for ele in eig_pairs[:k]]) data = np.dot(norm_X, np.transpose(feature)) return dataif __name__ == '__main__': X = load_iris().data # print(X) # X = np.array([[-1, 1], [-2, -1], [-3, -2], [1, 1], [2, 1], [3, 2]]) res = pca(X, 1) print(res)]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>python</tag>
        <tag>降维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写K-means及K-means++经典算法及实战]]></title>
    <url>%2F%E6%89%8B%E5%86%99K-means%E5%8F%8AK-means%2B%2B%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E5%8F%8A%E5%AE%9E%E6%88%98.html</url>
    <content type="text"><![CDATA[手写K-means及K-means++经典算法及实战 前段时间在学校，看了一篇关于K-means-u的聚类论文，当时对聚类只是听过，但对许多经典算法和练习都不够，所以今天专门记录一下，当然也查阅了网上许多资料，如果本文哪有纰漏，欢迎各位的批评和建议 关于K-means和K-means++的算法流程，我这里就不细讲了，之前做过一个PPT，点击下方链接即可查看 https://slides.com/huozhang/clusting/fullscreen K-means1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# 手写k-means算法# 导入必要的库import pandas as pdimport numpy as npimport matplotlib.pyplot as pltdef distance(dec1, dec2) -&gt; float: return np.sqrt(np.sum(np.square(dec1 - dec2))) # 计算欧式距离def K_Means(data, k): K = np.random.uniform(0, 10, (k, data.shape[1])) # 初始化中心点位矩阵 ret = np.zeros([data.shape[0], data.shape[1]]) # 构造一个答案矩阵 flag = True # 定义标记变量 count = 1 while flag: flag = False for i in range(data.shape[0]): minIndex = -1 # 定义得到最短距离的时候的临时中心点位 minDis = np.inf # 定义最短距离 for j in range(K.shape[0]): dis = distance(data[i], K[j]) # 计算距离 if dis &lt; minDis: minDis = dis minIndex = j # 计算完成后 将所属距离点位填入答案矩阵 ret[i][0] = minDis ret[i][1] = minIndex # 计算好位置了，现在开始重新计算均值，查询中心点 for i in range(k): cluster = data[ret[:, 1] == i] # print("中心点位——————", cluster) if len(cluster) == 0: pass else: center = np.mean(cluster, axis=0) # print("center 为", center) # print("K[i] 为", K[i]) if (center == K[i]).all(): # 这里必须用all()因为 ndarry()的性质 具体大家可以百度 pass else: K[i] = center flag = True _X = K[:, 0] _Y = K[:, 1] plt.scatter(_x, _y) plt.scatter(_X, _Y, marker='X', color='r') plt.title("%d of convergence" % count) count += 1 plt.show()if __name__ == '__main__': # 构造三簇数据 data1 = np.random.uniform(0, 2, (10, 2)) data2 = np.random.uniform(3, 6, (10, 2)) data3 = np.random.uniform(8, 10, (10, 2)) data = np.r_[data1, data2, data3] # 按列上下合并数据 np.c_[]是按行 左右合并 _x = data[:, 0] _y = data[:, 1] plt.rcParams['font.sans-serif'] = 'SimHei' # plt.scatter(_x, _y, marker="o") # plt.show() K_Means(data, 3) # 自定义定义3个中心 代码进行了可视化展示，可以看看每次收敛效果 K-means++ 主要解决K-means初始点位选择问题，k-means++即基本解决了这一问题，点位选择完成过后，进行相应的收敛和迭代，以减少迭代次数和SSE(最大平方误差和) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# 手写k-means++算法# 导入必要的库import numpy as npimport matplotlib.pyplot as pltimport randomimport mathdef euler_distance(point1, point2) -&gt; float: """ 计算两点之间的欧拉距离，支持多维 """ distance = 0.0 for a, b in zip(point1, point2): # 将x，y对应成元组进行计算 distance += math.pow(a - b, 2) return math.sqrt(distance)def distance(point, cluster) -&gt; float: min_dist = math.inf for i, centroid in enumerate(cluster): dist = euler_distance(centroid, point) # 计算每一个点到每个簇的距离 if dist &lt; min_dist: min_dist = dist return min_dist # 返回离簇最近的距离def KMeansplus(data, k) -&gt; list: """ K-means++ 主要解决K-means的初始点位选择问题，返回点位后，再进行收敛，此函数仅完成簇点选取 :param data: 数据集(测试集) :param k: 簇个数 :return: 返回簇x，y列表 """ cluster_list = [] cluster_list.append(random.choice(data).tolist()) ret = [0 for _ in range(len(data))] # 构造距离空列表 # print(ret) for _ in range(1, k): # 这里从第二个点开始，因为第一个点是随机的 sum_dis = 0 for i, point in enumerate(data): ret[i] = distance(point, cluster_list) sum_dis += ret[i] # 累加距离 sum_dis *= random.random() # 利用轮盘法*[0~1]里面的随机数 for i, point_dis in enumerate(ret): sum_dis -= point_dis # 依次减距离 if sum_dis &lt;= 0: cluster_list.append(data[i].tolist()) # 直到sum_dis为0时 将此点作为第二个点 break return cluster_list if __name__ == '__main__': # 构造三簇数据 data1 = np.random.uniform(0, 2, (20, 2)) data2 = np.random.uniform(3, 6, (20, 2)) data3 = np.random.uniform(8, 10, (20, 2)) data = np.r_[data1, data2, data3] # 按列上下合并数据 np.c_[]是按行 左右合并 np.random.shuffle(data) _x = data[:, 0] _y = data[:, 1] plt.rcParams['font.sans-serif'] = 'SimHei' plt.scatter(_x, _y, marker="o") center = KMeansplus(data, 3) # 自定义定义3个中心 # print("k-means++ 的中心为\n", center) center = np.array(center) center_x = center[:, 0] center_y = center[:, 1] plt.scatter(center_x, center_y, marker='X', c='r') plt.show() 可以看见在点位选择上基本和以完成收敛的点位非常接近，之后再通过几次收敛达到最佳]]></content>
      <categories>
        <category>机器学习</category>
        <category>聚类</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>python</tag>
        <tag>K-means，聚类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python自动化格式化文件夹名字(2.0版)]]></title>
    <url>%2Fchange%20filename.html</url>
    <content type="text"><![CDATA[每次同学交作业的格式都有问题，作为学委这是很头痛的事情，就想着用代码实现一些自动化的操作，来节约时间提升效率，这里主要就是os里面的改名功能，废话不多说，见代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import os, reimport pandas as pdimport timedef get_name_list(path): data = pd.read_excel(path, header=1) data = data.drop(0) data['学号'] = data['学号'].astype('int64') name_list = data[['姓名', '学号']] name_list = dict(name_list.values.tolist()) name_list = dict([str(value), key] for key, value in name_list.items()) return name_listdef to_rename(work_path, name_list): work_list = os.listdir(work_path) offer = [] for item in work_list: res_name = os.path.splitext(item) filename = res_name[0] filetype = res_name[1] try: st_number = re.findall(r'(1731\d+)', item)[0] right_name = st_number + "-" + name_list[st_number] offer.append(st_number) if item != right_name: os.rename(work_path + "/" + item, work_path + "/" + right_name + filetype) except: print("此文件学号格式错误或花名册中无此学号！---&gt;\033[0;31m%s\033[0m" % filename) to_check(offer, name_list)def to_check(offer_list, name_list): olist = [int(i) for i in offer_list] olist.sort() id_list = [17312020200 + i for i in range(1, 45)] no_offer = [i for i in id_list if i not in olist] print("分隔符".center(100, '=')) print("未交作业的同学为(共有\033[0;31m%d\033[0m人)：" % len(no_offer)) for item in no_offer: print(item, name_list[str(item)])def main(name_path, work_path): name_list = get_name_list(name_path) to_rename(work_path, name_list)if __name__ == '__main__': start = time.time() name_path = '../data/大数据二班花名册.xls' work_path = r'C:\Users\hp\Desktop\大数据17202数据科学（可视化）报告' main(name_path, work_path) end = time.time() print("一共耗时------&gt;%.2fs" % (end - start))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打印沙漏(简单思路)]]></title>
    <url>%2F%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F.html</url>
    <content type="text"><![CDATA[打印沙漏本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印 ***** *** * *** ***** 所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。 给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。 输入格式:输入在一行给出1个正整数N（≤\le≤1000）和一个符号，中间以空格分隔。 输出格式:首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。 输入样例:19 * 输出样例:***** *** * *** ***** 2 思路 ： 这里不讲百度一大堆的那种硬解的思路，而是通过python进行一个巧妙的转化 沙漏我们可以想象python里面的list列表[-3,-2,-1,0,1,2,3] 这种对称的 而打印出来 无非是找到对应的左右端口 其实就是找到沙漏的前半部分的h 我们通过大量画图模拟可以发现 给出数量和h的关系 h = \sqrt{(n+1)/2}h取整就是前半部分的加中心的值 比如n = 19 h 取整就为3 观察图形又是5行 就是模拟这个列表的过程[-2,-1,0,1,2] 如何达到？ 可以用 1map(abs,range(1-h,h)) # 来实现这个列表的模拟 接下来 我们就开始寻找 每一行输出多少个* 和 空格之间的关系了 话不多说 直接上代码 1234567n, ch = input().split(' ')n = int(n)h = int(((n + 1) / 2) ** 0.5)for i in map(abs, range(1 - h, h)): print(" " * (h - i - 1) + ch * (2 * i + 1))print(n - (2*h**2-1)) # 剩余 掌握了这h之间的关系后 同时我们也可以进行举一反三 比如给出首行的个数叫你进行相应的输出 1234n = int(input("请输入首行的*的个数："))h = int((n - 1) / 2) + 1for i in map(abs, range(1 - h, h)): print(" " * (h - 1 - i) + "*" * (i * 2 + 1))]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01机器学习入门--特征抽取]]></title>
    <url>%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B.html</url>
    <content type="text"><![CDATA[01机器学习入门—特征抽取8月了。。这几天也是边干活边学习机器学习，空余时间我还是想把这些记录下来 这里我就记录3个方法 字典特征值抽取123456789DictVectorizer(sparse=True,..)DictVectorizer.fit_transform(X) * X: array数组或者sparse矩阵 * 返回值：转换之前的数据格式DictVectorizer.get_feature_names() * 返回类别的名称DictVectorizer.transform(X) * 按照原先的标准转换 文本特征值抽取123456789CountVectorizer() # 返回词频矩阵CountVectorizer.fit_transform(X) * X: 文本或者包含文本字符串的可迭代对象 * 返回值: 返回sparse矩阵CountVectorizer.inverse_transform(X) * X: array数组或者sparse矩阵CountVectoreizer.get_feature_names() * 返回值: 单词列表 Tfidf文本特征抽取分析问题Tf: term frequency —&gt; 词的频率 idf: 逆文档频率inverse document frequency 一下内容来自维基百科 tf-idf（英语：term frequency–inverse document frequency）是一种用于信息检索与文本挖掘的常用加权技术。tf-idf是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。tf-idf加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。除了tf-idf以外，互联网上的搜索引擎还会使用基于链接分析的评级方法，以确定文件在搜索结果中出现的顺序。 Tf-idf计算公式 ——&gt; lg(总文档数量/该词出现的文档数量) tf-idf的理论依据及不足 tf-idf算法是创建在这样一个假设之上的：对区别文档最有意义的词语应该是那些在文档中出现频率高，而在整个文档集合的其他文档中出现频率少的词语，所以如果特征空间坐标系取tf词频作为测度，就可以体现同类文本的特点。另外考虑到单词区别不同类别的能力，tf-idf法认为一个单词出现的文本频数越小，它区别不同类别文本的能力就越大。因此引入了逆文本频度idf的概念，以tf和idf的乘积作为特征空间坐标系的取值测度，并用它完成对权值tf的调整，调整权值的目的在于突出重要单词，抑制次要单词。但是在本质上idf是一种试图抑制噪声的加权，并且单纯地认为文本频率小的单词就越重要，文本频率大的单词就越无用，显然这并不是完全正确的。idf的简单结构并不能有效地反映单词的重要程度和特征词的分布情况，使其无法很好地完成对权值调整的功能，所以tf-idf法的精度并不是很高。 此外，在tf-idf算法中并没有体现出单词的位置信息，对于Web文档而言，权重的计算方法应该体现出HTML的结构特征。特征词在不同的标记符中对文章内容的反映程度不同，其权重的计算方法也应不同。因此应该对于处于网页不同位置的特征词分别赋予不同的系数，然后乘以特征词的词频，以提高文本表示的效果。 例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# examplefrom sklearn.feature_extraction import DictVectorizerfrom sklearn.feature_extraction.text import CountVectorizer,TfidfVectorizerimport jiebadef WordCut(): """ 中文分词 """ con = jieba.cut("人生苦短,我用python,人生漫长,我不用python") # 转为列表 content = list(con) # 列表转为字符串，忽略空格字符等 c = ' '.join(content) return c def DictVec(): ''' 字典特征抽取 sparse矩阵 节约内存，方便读取处理 ''' dict = DictVectorizer(sparse=False) data = dict.fit_transform([&#123;"city":"北京","PM2.5":123&#125;,&#123;"city":"成都","PM2.5":5&#125;]) print(dict.get_feature_names()) print(data) return None def CountVec(): """ 文本特征值抽取 对于单个字母不进行统计，没有分类依据 """ cv = CountVectorizer() # 没有sparse矩阵调节参数# data = cv.fit_transform(["Life is short,i like python","life is long,i dislike python"])# data = cv.fit_transform(["人生苦短,我用python","人生漫长,我不用python"]) # 无法对中文进行准确的抽取 # 先要自行进行分词(可以加空格或用jieba) ans = WordCut() print(ans) data = cv.fit_transform([ans]) print(cv.get_feature_names()) print(data.toarray()) # 通过toarray()方法进行转化 def tfidfVec(): """ 文本特征值抽取 对于单个字母不进行统计，没有分类依据 """ cv = TfidfVectorizer() ans = WordCut() print(ans) data = cv.fit_transform([ans]) print(cv.get_feature_names()) print(data.toarray()) # 通过toarray()方法进行转化 if __name__ == "__main__": DictVec() CountVec() tfidfVec() 但这些远不够，特征处理是什么？ 通过特定的统计方法(数学方法)将数据转换成算法要求的数据 这里我们可以分成几大类 数值型数据： 标准缩放：API —&gt; sklearn. preprocessing 11. 归一化 标准化 缺失值 类别型数据：one-hot编码 时间类型：时间的切分 （pandas） 归一化**特点:**通过对原始数据进行变换把数据映射到（默认为[0,1]）之间 $$ X' = \frac{x-min}{max-min} \\ $$ $$ X'' = X'*(mx-mi)+mi $$ **Ps**：作用于每一列，max为一列的最大值，min为一列的最小值,那么X’’为最终结果，mx，mi分别为指定区间值默认mx为1,mi为0 那为什么我们要做这些处理呢？见下方案例 ![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hZTAxLmFsaWNkbi5jb20va2YvSGJkNDQ0OTE4NmU3ZDQ2OWU4N2Y2MDNmMjJhODYwYTlkUy5wbmc) 如果单从这三种数据来相亲肯定是不公平的 我们进行下计算 $$ (72993-35948)^2+(10.141740-6830792)^2+(1.032955-1.213192)^2 $$ 我们可以清晰的发现，里程数几乎占了总体指数的全部，所以我们要进行标准缩放 **核心目的：** **其实就是让某一个特征对最终结果不会造成更大的影响** 123456MinMaxScaler(feature_range(0,1)...)* 每个特征缩放到给定范围(默认[0,1])MinMaxScaler.fit_transform(X)* X：numpy array 格式的数据[n_samples,n_features]* 返回值：转换后的形状相同的array 归一化步骤： 实例化MinMaxScalar 通过fit_transform转换 123456789101112131415161718192021from sklearn.preprocessing import MinMaxScalerdef MM(): """ 进行归一化 :return:None """ mm = MinMaxScaler(feature_range=(2, 3)) # 返回2-3 data = mm.fit_transform([[90, 2, 10, 40], [60, 4, 15, 45], [75, 3, 13, 46]]) print(data) return Noneif __name__ == '__main__': MM(); 结果： [[3. 2. 2. 2. ] [2. 3. 3. 2.83333333] [2.5 2.5 2.6 3. ]] Ps：特定场景下最大值最小值是变化的，另外，最大值与最小值非常容易受异常点影响，所以这种方法鲁棒性（稳定性）较差，只适合传统精确小数据场景。 所以引入标准化 标准化 特点：通过对原始数据进行变化把数据变化到均值为0，方差为1的范围内 公式：- X' = \frac{x-mean}{σ} 注:作用于每一列，mean为平均值，σ为标准差(考量数据的稳定性) 对于归一化来说：如果出现异常点，影响了最大值和最小值，那么结果显然会发生改变 对于标准化来说：如果出现异常点，由于具有一定数据量，少量的异常点对于平均值的影响并不大，从而方差改变较小。 123456789101112StandardScaler(…)# 处理之后每列来说所有数据都聚集在均值0附近方差为1* StandardScaler.fit_transform(X,y) #X:numpy array格式的数据[n_samples,n_features]#返回值：转换后的形状相同的array* StandardScaler.mean_#原始数据中每列特征的平均值* StandardScaler.std_#原始数据每列特征的方差 应用： 12345678910111213141516171819202122from sklearn.preprocessing import StandardScalerdef SS(): """ 进行标准化 :return: None """ ss = StandardScaler() data = ss.fit_transform([[1., -1., 3.], [2., 4., 2.], [4., 6., -1.]]) print(data) return Noneif __name__ == '__main__': SS(); # 结果：[[-1.06904497 -1.35873244 0.98058068] [-0.26726124 0.33968311 0.39223227] [ 1.33630621 1.01904933 -1.37281295]] 平常大部分缩放都用标准化，因为在已有样本足够多的情况下比较稳定，适合现代嘈杂大数据场景。 如何处理数据中的缺失值？ 删除 如果每列或者行数据缺失值达到一定的比例，建议放弃整行或者整列 插补 可以通过缺失值每行或者每列的平均值、中位数来填充 sklearn缺失值API: sklearn.preprocessing.Imputer 123456Imputer(missing_values='NaN', strategy='mean', axis=0)#完成缺失值插补* Imputer.fit_transform(X,y) #X:numpy array格式的数据[n_samples,n_features]#返回值：转换后的形状相同的array Imputer流程 初始化Imputer,指定”缺失值”，指定填补策略，指定行或列（注：缺失值也可以是别的指定要替换的值） 调用fit_transform 123456789101112131415161718192021222324from sklearn.preprocessing import Imputerimport numpy as npdef ipt(): """ 进行缺值插入 :return: None """ ans = Imputer(missing_values="NaN", strategy="mean", axis=0) # axis = 0为列 1为行 data = ans.fit_transform([[1, 2], [np.nan, 3], [7, 6]]) print(data) return Noneif __name__ == '__main__': ipt() # 结果：[[1. 2.] [4. 3.] [7. 6.]]]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>特征值处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基本使用方法(小白)]]></title>
    <url>%2Fgit.html</url>
    <content type="text"><![CDATA[Github大型同性交友网站，连git都不会怎么快乐呢♂？不多说废话，看图 上面是不是太长了。。。别慌 下面还有一张 如果这些还不够用去我的频道收看git简明使用教程]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各类经典排序汇总(结合视频)]]></title>
    <url>%2F%E5%90%84%E7%B1%BB%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[各类基础排序汇总昨晚和几个ACM的朋友谈了会儿人生，原本危机感已经很强的我突然压力又大了起来😐，今天小程序全国晋级名单也没有我，反复扫了几遍还是没有，心一下凉了半截😌，不断学习进步才是王道呀。最近也在回顾数据结构，顺便自己也来总结一下几大经典排序算法。由于自己实力有限，若本文有任何纰漏或者大佬有什么好的建议，可以到底部留言区进行讨论与留言O(∩_∩)O 或通过右下角直接联系我噢 !! 所属类别graph TD A[排序] --> B{内部排序--使用内存}; B --> D(插入排序); D --> I(直接插入排序); D --> J(希尔排序); B --> E(选择排序); E --> K(简单选择排序); E --> L(堆排序); B --> F(交换排序); F --> M(冒泡排序); F --> N(快速排序); B --> G(归并排序); B --> H(基数排序->俗称桶排序); A --> C[外部排序--内存与外存相结合使用]; 各大排序的复杂度比较什么是稳定排序？ 待排序的记录序列中可能存在两个或两个以上关键字相等的记录。排序前的序列中Ri领先于Rj（即i&lt;j）.若在排序后的序列中Ri仍然领先于Rj，则称所用的方法是稳定的。 排序名称 平均时间复杂度 最好时间复杂度 最坏时间复杂度 空间复杂度 稳定性 建议 直接插入排序 O(N^2) O(N) [如果有序，那么每个元素都已经在在它的待排子序列的合适位置，不用找合适位置] O(N^2) O(1) 稳定 由于每次只能移动一位，建议使用希尔排序 希尔排序 O(N^1.3) O(N^2) O(N^2) O(1) 不稳定 选取合适的增量，一般选取为d = n/2，依次选下去，直到d为1 简单选择排序 O(N^2) O(N^2) O(N^2) O(1) 稳定 堆排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 不稳定 冒泡排序 O(N^2) O(N^2) O(N^2) O(1) 稳定 快速排序 O(nlog2n) O(nlog2n) O(N^2) O(nlog2n) [递归占用空间栈较多] 不稳定 归并排序 O(nlog2n) O(nlog2n) O(nlog2n) O(N) 稳定 但是这种算法很消耗空间，一般来说在内部排序不会用这种方法，而是用快速排序；外部排序才会考虑到使用这种方法 基数排序 O(D(N+R)) O(D(N+R)) O(D(N+R)) O(N+R) 稳定 各排序代码讲解贴一个排序在线动画演示，有兴趣的同学可以点进去加深印象 代码我用C来进行演示，算法重要的是思想，同学们可以尝试用自己的语言来实现 现在网络资源很多，并且好的讲解许多，关于一些排序的基本理论思想，我这给大家推荐几个视频通俗易懂 前人栽树，后人乘凉呀😁 简单排序 堆排序 归并排序 递归基础 插入排序：直接插入排序 InsertSort 主要核心理解：将一组序列分为有序和无序两个部分，每次将无序的元素在合适的index值插入到有序序列 123456789101112131415161718192021222324#include&lt;stdio.h&gt;int main()&#123; int n,a[50]; scanf("%d",&amp;n); for(int i = 0;i&lt;n;i++) &#123; scanf("%d",&amp;a[i]); &#125; for(int i = 1;i&lt;n;i++) // 从a[1]开始 因为a[0]一个数字默认有序 &#123; int key = a[i]; // 确立待插入的值 while(i &gt; 0 &amp;&amp; a[i-1] &gt; key) // 将key值与有序序列进行比较 &#123; a[i] = a[i-1]; // 前面的值往后移 i--; // 索引往前移，继续找合适的位置 &#125; a[i] = key; // 找到合适的位置了，将key插入到序列中 &#125; for(int i = 0;i&lt;n;i++) printf("%d%c",a[i],i==n-1?'\n':' '); return 0;&#125; 希尔排序 ShellSort 插入排序升级版，用增量解决直接插入排序的每次只能移动1位的缺点 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;int main()&#123; int n,a[50]; scanf("%d",&amp;n); for(int i = 0;i&lt;n;i++) &#123; scanf("%d",&amp;a[i]); &#125; int step; for(step = n/2;step &gt;= 1;step/=2) // 这里增量每次按一般取 &#123; for(int i = step;i&lt;n;i++) // 依次对按增量分类的序列进行插入排序 &#123; int j = i; int key = a[j]; while(j - step &gt;= 0 &amp;&amp; a[j-step] &gt; key) &#123; a[j] = a[j-step]; j = j - step; &#125; a[j] = key; &#125; &#125; for(int i = 0;i&lt;n;i++) printf("%d%c",a[i],i==n-1?'\n':' '); return 0;&#125; 选择排序：简单选择排序 SelectSort 每次在数组中找到最大（最小）的index值 然后与第一个值进行交换 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int main()&#123; int n,a[50]; scanf("%d",&amp;n); for(int i = 0;i&lt;n;i++) &#123; scanf("%d",&amp;a[i]); &#125; for(int i = 0;i&lt;n-1;i++) &#123; int index = i; for(int j = i+1;j&lt;n;j++) &#123; if(a[j] &gt; a[index]) &#123; index = j; &#125; &#125; int tmp = a[i]; a[i] = a[index]; a[index] = tmp; &#125; for(int i = 0;i&lt;n;i++) printf("%d%c",a[i],i==n-1?'\n':' '); return 0;&#125; 堆排序 HeapSort 其实就是利用堆这种数据结构，巧妙的进行排序，堆是一个近似完全二叉树的结构。 这里的思想见上面的堆排序视频讲解（up主讲解的通俗易懂，强烈推荐），我相信声音 + 图片的知识接收程度一定大于只看文字 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/// O(n*logn)#include&lt;stdio.h&gt;void swap(int tree[],int i,int j)&#123; int tmp = tree[i]; tree[i] = tree[j]; tree[j] = tmp;&#125;void heapify(int tree[],int n,int i)&#123; if(i&gt;=n) return; int c1 = 2*i+1; // 左节点 int c2 = 2*i+2; // 右节点 int max = i; if(c1 &lt; n &amp;&amp; tree[c1] &gt; tree[max]) &#123; max = c1; &#125; if(c2 &lt; n &amp;&amp; tree[c2] &gt; tree[max]) &#123; max = c2; &#125; if(max != i) // 若最大值的index与i不想等 就进行交换 &#123; swap(tree,max,i); heapify(tree,n,max); // 对当前最大值max节点进行递归 找出最大的值不断进行交换 &#125;&#125;void build_heap(int tree[],int n) &#123; int last_node = n - 1; int parent = (last_node - 1)/2; for(int i = parent; i &gt;= 0; i--) &#123; heapify(tree,n,i); &#125;&#125;void heap_sort(int tree[],int n)&#123; build_heap(tree,n); for(int i = n-1;i &gt;= 0;i--) &#123; swap(tree,i,0); // 最后一个节点与第一个节点交换（最小和最大的节点swap） heapify(tree,i,0); // 对最上面三个节点进行heapify 重新形成堆 这里n值用i来传 因为每次都会分离出最大值，所以节点数会每次递减1 &#125;&#125;int main()&#123; int n; int tree[50]; scanf("%d",&amp;n); for(int i = 0; i&lt;n; i++) scanf("%d",&amp;tree[i]); // heapify(tree,n,0); // build_heap(tree,n); heap_sort(tree,n); for(int i = 0; i&lt;n; i++) &#123; printf("%d%c",tree[i],i==n-1?'\n':' '); &#125; return 0;&#125; 交换排序：冒泡排序 冒泡，简单来说就是每次两两交换后都把把最大(最小)的值先放在最后面。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int main()&#123; int n,a[50]; scanf("%d",&amp;n); for(int i = 0;i&lt;n;i++) &#123; scanf("%d",&amp;a[i]); &#125; for(int i = 0;i&lt;n-1;i++) // 一共要排n-1次 &#123; /* 为什么是n-i-1呢？ 先不看减i 我们先看n-1 每次我们都是比较a[j]与a[j+1] 如果不减1 数组就会越界 再来看为什么减i 每排完一次序 就有1个最大或最小值排在最后面 所以每排了多少次 后面就应经有多少个有序的数字了 i值又是控制次数的 So每次要减i */ for(int j = 0;j&lt;n-i-1;j++) &#123; if(a[j] &gt; a[j+1]) &#123; int tmp = a[j]; a[j] = a[j + 1]; a[j+1] = tmp; &#125; &#125; &#125; for(int i = 0;i&lt;n;i++) printf("%d%c",a[i],i==n-1?'\n':' '); return 0;&#125; 快速排序 Quicksort 快速排序（Quicksort）是对冒泡排序的一种改进。不同的是，冒泡排序在每一轮只把一个元素冒泡到数列的一端，而快速排序在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成了两个部分。 我们可以看到这个动图，把大于6的分到一边，把小于6的分成一部分，再分别对这两部分进行相同的操作，直到还剩1个元素时，我们通过下面的例子来模拟一下 以一个实例模拟快速排序的过程: 设数组A为将要进行排序的数组 A=\{8,7,13,11,9,6,7,15,10,5\}快排的过程如下： 其中红色字体表示每一段子序列进行排序时所选择的基准元素，蓝色填充色的方块表示已经找到基准元素所处的位置。 从上图可以看出，每一个进行排序的序列都要经历三个过程：一是选择则基准元素（上述都选择第一个元素为基准元素），二是对基准元素进行寻址，三是将序列划分成两个子序列并重复上述的工作。 123456789101112131415161718192021222324252627282930313233343536373839404142/// O(n*logn ~ n*2)#include&lt;stdio.h&gt;void quickSort(int arr[],int l,int r)&#123; if(l &gt;= r) // 递归出口 说明只有一个元素时 回退 return; int k = arr[l]; int i,j; i = l; j = r; while(i != j) // 当左哨兵 和 右哨兵没有碰头时 进行两部分的交换 &#123; while(j&gt;i &amp;&amp; arr[j] &gt;= k) // 如果右边有比k大的就判断前一个值 否则就与哨兵i所在值进行交换 j--; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; while(i&lt;j &amp;&amp; arr[i] &lt;= k) // 如果左边有比k小的就判断后一个值 否则就与哨兵j所在值进行交换 i++; tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125; quickSort(arr,l,i-1); // 对左边递归 这里一个函数两个递归 如果不是理解很清楚的话 建议手动模拟一遍 若对递 归了解的不是很清晰 可以去之前推荐视频里看看 quickSort(arr,i+1,r); // 对右部分递归 &#125;int main()&#123; int arr[50]; int n; scanf("%d",&amp;n); for(int i = 0; i&lt;n; i++) &#123; scanf("%d",&amp;arr[i]); &#125; quickSort(arr,0,n-1); // 这里传的r和l都是索引值 for(int i = 0; i&lt;n; i++) printf("%d%c",arr[i],i==n-1?'\n':' '); return 0;&#125; 归并排序 MergeSort 归并和快排都用到了分治的思想 就是将原序列划分成两个等长子序列，再递归地排序这两个子序列，最后再调用归并操作合并成一个完整的有序数列 说白了就是 先分再合成有序 具体思想还是见上面的推荐视频 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;void merge(int arr[],int L,int R,int M)&#123; int LIET_SIZE = M - L ; int RIGHT_SIZE = R - M + 1; int lift[LIET_SIZE]; int right[RIGHT_SIZE]; int i,j,k; for(i = L;i &lt;=M ;i++) &#123; lift[i - L] = arr[i]; &#125; for(i = M;i&lt;=R;i++) &#123; right[i - M] = arr[i]; // printf("r = %d\n",right[i-M]); &#125; i = j = 0; k = L; while(i &lt; LIET_SIZE &amp;&amp; j &lt; RIGHT_SIZE) &#123; if(lift[i] &lt; right[j]) &#123; arr[k] = lift[i]; k++; i++; &#125; else &#123; arr[k] = right[j]; k++; j++; &#125; &#125; while(i &lt; LIET_SIZE) &#123; arr[k++] = lift[i]; i++; &#125; while(j &lt; RIGHT_SIZE) &#123; arr[k++] = right[j]; j++; &#125;&#125;void mergesort(int arr[],int L,int R)&#123; if(R == L) &#123; return; &#125; else&#123; int M = L + (R-L)/2; mergesort(arr,L,M); mergesort(arr,M+1,R); merge(arr,L,R,M+1); &#125;&#125;int main() &#123; int arr[10] = &#123;2,8,9,10,4,5,6,7&#125;; int R = 7; int L = 0; mergesort(arr,L,R); for(int i = 0;i&lt;8;i++) &#123; printf("%d ",arr[i]); &#125;&#125; 基数排序（不会，占时先留着）未完待续。。。]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整数分解为若干项之和(DFS小白入门)]]></title>
    <url>%2F%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3%E4%B8%BA%E8%8B%A5%E5%B9%B2%E9%A1%B9%E4%B9%8B%E5%92%8C.html</url>
    <content type="text"><![CDATA[整数分解为若干项之和(DFS小白入门)将一个正整数N分解成几个正整数相加，可以有多种分解方法，例如7=6+1，7=5+2，7=5+1+1，…。编程求出正整数N的所有整数分解式子。 输入格式：每个输入包含一个测试用例，即正整数N (0&lt;N≤30)。 输出格式：按递增顺序输出N的所有整数分解式子。递增顺序是指：对于两个分解序列N1={n1,n2,⋯}和N2={m1,m2,⋯}，若存在i使得n1=m1,⋯,n**i=m**i，但是n**i+1&lt;m**i+1,则N1序列必定在N2序列之前输出。每个式子由小到大相加，式子间用分号隔开，且每输出4个式子后换行。 输入样例：7 输出样例：7=1+1+1+1+1+1+1;7=1+1+1+1+1+2;7=1+1+1+1+3;7=1+1+1+2+2 7=1+1+1+4;7=1+1+2+3;7=1+1+5;7=1+2+2+2 7=1+2+4;7=1+3+3;7=1+6;7=2+2+3 7=2+5;7=3+4;7=7 看这种多种情况并且多种分解的 首先就要想到树 发现多种情况，和全排列有点像，果断DFS 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;#define MAX 500int a[MAX];int n;int cnt = 0,sum = 0;int k = 0;void DFS(int step)&#123; if(sum == n) // 总和与输入值相等时，进行输出 &#123; k++; printf("%d=",n); if(k%4 == 0 || a[cnt-1] == n) // 对格式进行适当的调整 &#123; for(int i = 0; i&lt;cnt; i++) &#123; printf("%d%c",a[i],i==cnt-1?'\n':'+'); &#125; &#125; else if(k%4) &#123; for(int i = 0; i&lt;cnt; i++) &#123; printf("%d%c",a[i],i==cnt-1?';':'+'); &#125; &#125; return; &#125; else if(sum &gt; n) return; for(int i = step; i&lt;=n; i++) &#123; a[cnt++] = i; sum += i; DFS(i); // 遍历下一个节点 sum -= i;// 回溯为上一个节点 所以要减去i cnt--; // 同样回溯 &#125;&#125;int main()&#123; scanf("%d",&amp;n); DFS(1); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[币值转换（模拟）]]></title>
    <url>%2F%E5%B8%81%E5%80%BC%E8%BD%AC%E6%8D%A2.html</url>
    <content type="text"><![CDATA[7-23 币值转换 (20 分) 输入一个整数（位数不超过9位）代表一个人民币值（单位为元），请转换成财务要求的大写中文格式。如23108元，转换后变成“贰万叁仟壹百零捌”元。为了简化输出，用小写英文字母a-j顺序代表大写数字0-9，用S、B、Q、W、Y分别代表拾、百、仟、万、亿。于是23108元应被转换输出为“cWdQbBai”元。 输入格式：输入在一行中给出一个不超过9位的非负整数。 输出格式：在一行中输出转换后的结果。注意“零”的用法必须符合中文习惯。 输入样例1：813227345 输出样例1：iYbQdBcScWhQdBeSf 输入样例2：6900 输出样例2：gQjB 作者: 陈建海 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;int main ()&#123; int n, initial_n; scanf("%d", &amp;n); initial_n = n; // 保留初始值 char num[10] = &#123;'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'&#125;; char unit[10] = &#123;0, 0, 'S', 'B', 'Q', 'W', 'S', 'B', 'Q', 'Y'&#125;;//舍弃前两位 char result[17]= &#123;0&#125;; // 9 位数最多有 17 位输出 int i = 0, last_i = n % 10; int j = 0; int count_n = 0; while (n &gt; 0) &#123; i = n % 10; n /= 10; count_n ++; if (i == 0 &amp;&amp; (count_n % 4) &gt; 1) // 从十位开始统计（个位0永远不输出） &#123; if (last_i != 0) // 如果前一位不等于 0，那就输出这个 0 &#123; result[j++] = num[i]; &#125; &#125; if (count_n == 5 &amp;&amp; i == 0 &amp;&amp; initial_n &lt; 100000000) &#123; result[j++] = unit[count_n]; // 万 w 是一定要输出的 &#125; if (count_n &gt; 1 &amp;&amp; i != 0) // 非 0 不输出单位 &#123; result[j++] = unit[count_n]; &#125; if (i != 0) // 处理非 0 数的输出 &#123; result[j++] = num[i]; &#125; last_i = i; //保留 i 的前一位的值 用于处理 0 &#125; if (initial_n == 0) // 处理特殊值 0 &#123; result[j++] = num[i]; &#125; for (j=j-1; j&gt;=0; j--) &#123; printf("%c", result[j]); &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux(redhat)安装gcc环境]]></title>
    <url>%2FLinux(redhat)%E5%AE%89%E8%A3%85gcc%E7%8E%AF%E5%A2%83%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%EF%BC%8C%E9%92%88%E5%AF%B9%E5%B0%8F%E7%99%BD%EF%BC%8C%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86%EF%BC%89.html</url>
    <content type="text"><![CDATA[前言：看来网上许多博客都是抄来抄去的基本一个样，还有许多坑，现在博主就来详细的介绍如何从无到有的在你的Linux环境里安装上gcc 注意:在配置gcc之前先把虚拟机的开机顺序调整正确！！！ 话不多说见图：如果不能点击就先关闭虚拟机在进行设置 现在开始 1.（先完成最上面那步再来做第一步）点击最上面的设备—&gt;分配光驱—&gt;选择你自己当前系统的.iso镜像文件选择好以后你桌面上就有一个光驱 2.开始进行挂载1）挂载光盘123cd /mntmkdir cdrommount /dev/cdrom /mnt/cdrom 2）进入软件包目录123cd /mnt/cdrom/Packagesls –la gcc*.*rpm –ivh gcc-4.4.7-3.el6.i686.rpm // 这里大家安装自己的版本(输入前几个关键字母后就用table键补齐) 不一定是我这写的版本 然后Enter进行安装，如果这安装出现问题不用管，直接进入第三步安装 3.安装以下rpm包 （从上到下依次安装，顺序一定不能乱！！）安装的时候名字不用全打,打了前面几个字母按table自动补全 注意：安装包的时候一定要根据自己包的版本安装，利用table键补齐。如果存在包的依赖关系报错的话，就先检查顺序是否正确，安装包的时候最好安装x84_64结尾的包 注意天坑: 在安装第4个rpm包的时候如果有图中红框的一定要选择图中方框这个包，不然后续会找不到对应的环境，如果没有的这个包的话还是安装i686.rpm结尾的！！！！ 12345678rpm -ivh kernel-headers-2.6.32-358.el6.i686.rpm rpm -ivh glibc-headers-2.12-1.107.el6.i686.rpm rpm -ivh glibc-devel-2.12-1.107.el6.i686.rpm rpm -ivh mpfr-2.4.1-6.el6.i686.rpm（依赖libmpfr.so.1） rpm -ivh cpp-4.4.7-3.el6.i686.rpm rpm -ivh ppl-0.10.2-11.el6.i686.rpm（依赖libppl.so.7和libppl_c.so.2）rpm -ivh cloog-ppl-0.15.7-1.2.el6.i686.rpm rpm -ivh gcc-4.4.7-3.el6.i686.rpm 4.安装好以后随便在一个文件夹中进行测试看是否成功我这是在根目录下面建了一个test文件夹 vim word.c进行编辑 在用gcc运行 大功告成，安装gcc成功，如果本文有什么错误或者知识点的遗漏欢迎大家指出！]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的询问（延时标记+差分）]]></title>
    <url>%2F%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%A2%E9%97%AE.html</url>
    <content type="text"><![CDATA[Problem A: 简单的询问Time Limit: 1 Sec Memory Limit: 64 MB Description给你N个区间[Li,Ri]，有Q个询问。 每个询问问，num这个数是否在给出的某个区间内。 Input输入第一行有一个正整数T(T&lt;=10)，表示组数； 每组数据第一行有两个正整数N,Q(N,Q&lt;=1e5)，意义如题； 接下来行每行包含两个正整数Li,Ri(Li]]></content>
      <categories>
        <category>算法</category>
        <category>差分数组</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Carryon 数数字(小米OJ)]]></title>
    <url>%2FCarryon%20%E6%95%B0%E6%95%B0%E5%AD%97.html</url>
    <content type="text"><![CDATA[Carryon 数数字序号：#138 难度：困难 时间限制：1000ms 内存限制：80M 描述Carryon 最近迷上了数数字，然后 Starry 给了他一个区间 [l,r] ,然后提了几个要求， 需要将 l 到 r 之间的数全部转化成 16 进制，然后连起来。 将连起来的数又转化成 10 进制。 将最终结果对 15 取模。 数据范围： $1&lt;=l&lt;=r&lt;=1000000000000$ 输入单组输入 l 和 r 的值 输出输出最终结果。 输入样例10 14 输出样例0 小提示如：10、11、12、13、14的16进制分别是a、b、c、d、e。依次连在一起是abcde，转换成10进制是703710，对15取模为0。 思路： 先看范围1~1e12 用普通for循环肯定超时，就要想怎么缩小范围，我们就先看取余 来看看为什么这里优化是 $c = a + (b - a)\%15$ 因为最后也要对15求余，我们就先对范围内取余来达到缩小范围这样也会保证结果相同以致不会超时1234567891011121314151617181920import sysfor line in sys.stdin: line = line.strip() a, b = map(int, line.split()) str = "" res = "" c = a + (b - a) % 15 # 先求个余 缩小范围 for i in range(a, c + 1): str += hex(i) # 每次加每个数的16进制 str = str.replace('0x', '') # 替换0x无用字符 for i in range(a, b + 1): ans = hex(i) res += ans res = res.replace('0x', '') print("优化前:" + res) print("优化后:" + str) print(int(str, 16) % 15) # 再从16进制转10进制取余 看下结果 123456789101112131415161718191 16优化前:123456789abcdef10优化后:111 99优化前:123456789abcdef101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f60616263优化后:123456789010 14优化前:abcde优化后:abcde02 21优化前:23456789abcdef101112131415优化后:234565 12345678910import sysfor line in sys.stdin: line = line.strip() a,b= line.split() str = "" c = int(a) + (int(b)-int(a)) % 15 # 先求个余 缩小范围 for i in range(int(a), int(c)+1): str += hex(i) # 每次加每个数的16进制 str = str.replace('0x', '') # 替换0x无用字符 print(int(str, 16) % 15) # 再从16进制转10进制取余]]></content>
      <categories>
        <category>算法</category>
        <category>取余优化</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python单线程爬取QQ空间说说存入MySQL并生成词云（超详细讲解，踩坑经历）]]></title>
    <url>%2Fpython.html</url>
    <content type="text"><![CDATA[利用python爬取好友说说并分析 看了网上的许多博客，基本上都是一个样，基本的知识也没详细解释，我这次也想跟大家仔细分析一下，自己还是要有一定爬虫基础，本人技术有限，如果本文哪有错误或不够准确的地方，还望大牛们指点ヾ(๑╹◡╹)ﾉ” 一、环境配置： Python 3.6 selenium (注意:先配置好自己浏览器的驱动，下载地址看下面) pymysql re requests 点击下载chrome的——&gt;Chrome_webdriver点击下载Firefox的——&gt;Firefox_webdriver点击下载IE的——&gt;IE_webdriver 先来张效果图看看效果 二、思路： 作为一个菜鸡学了一点爬虫，就想做一个好友的说说分析，最开始我以为这个爬虫很简单几十行就可以搞定，然而忽略了一些东西。。。。（先卖个关子） 先说说整个过程的想法： 看起来是不是很简单？（手动dog）那现在我们就来按步骤操作一下 1.找到包含好友的QQ信息的url（这里也有两种方法） 法一：先点开好友这一栏,通过亲密度的排行来获取，这里我们点开F12，选中Network一般这种信息都在XHR或者JS类型里面，大家可以在这里面找找，通过一会的寻找我们就发现friend_ship开头这xhr里面的items_list就包含了好友的QQ号和姓名，但是此方法获取的qq不全，只是大部分的qq 法二：点击页面最上面的设置按钮，滑动可见好友，通过js的结果分析，随着下滑请求的url的页数都在变化，我们只要每次修改下页数的参数就可以获取所有好友的QQ，这个方法可以获取所有的好友的qq，但对于qq好友很少的朋友来说，此方法不适用 2.找到包含好友的说说的url我们先随便点进一个好友的空间进行分析点进去过后，我们F12 进行分析，发现一页最多存20条说说，以此我们可以通过说说总数（re提取）来算出一共有多少页，然后通过构造url来获取 通过以上的分析过后我们开始获取url： 我们先看看获取qq的第一种方法的url：&gt; https://user.qzone.qq.com/proxy/domain/r.qzone.qq.com/cgi-bin/tfriend/friend_ship_manager.cgi?uin=你的QQ号&amp;do=1&amp;rd=0.55484478707938&amp;fupdate=1&amp;clean=1&amp;g_tk=1376935160&amp;qzonetoken=6e4e0b063e3f00421d98df35b330c8bb2158bb8697e5dc7a85a65b379407706960f0b1c422f9a26879&amp;g_tk=1376935160 我们分析一下这里面每次登录都在变的参数 g_tk （空间加密算法） qzonetoken （空间源码里面的参数） 那这两个参数我们要怎么获取呢？为什么每次登录这两个参数的都在变呢？ 我们首先先要了解一下——&gt;cookie在看看session的基本概念 快速查看 cookies 的方法：按F12进入浏览器的开发者模式——console——在命令行输入javascript:alert(document.cookie)，再回车即可看见 所以我们登录过后，每次都访问url的时候都要保持着参数不变，也就是说cookie不能变每次都要是同一个cookie(就相当于每次都是以你的身份保持着登录状态去访问他人空间)，否则就会出现以下情况↓ 理解好以上的几个问题过后，问题就解决了一大部分了接着我们分析g_tk参数，在自己qq空间主页 F12 点JS类型文件，找到以下文件,查看Preview部分，分析一下其中的代码 其实这个程序的意思， 还是直接上代码吧1234567891011def get_tk(cookie): hashes = 5381 for i in cookie['p_skey']: #提取cookie中p_skey每个字母 hashes += (hashes &lt;&lt; 5) + ord(i) #加密过程,ord()将 字符转化为ASCII码 # &lt;&lt; 二进制 左移运算 左移几位就相当于乘以2的几次方 return hashes &amp; 2147483647 #二进制 与运算 # 比如 2&amp;3 转为二进制 10&amp;11 # 都是1结果为1，否则为0 # 所以二进制算出来是 10 返回2 # 还不懂的朋友，还是自行Baidu吧 随着我们分析第二个参数qzonetoken这个参数很好获取，在我们空间主页右键查看网页源代码,Ctrl+F查找下可以找到，之后我们可以通过正则提取ok，理解了上面的全部，基本就完成了80%了，接下来我们开始代码实现 三、代码实现：先导入第三方库1234567import re, requestsimport time, pymysqlfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as EC 首先是登录，我们这里用selenium模拟浏览器实现 1234567891011121314151617181920def login(): driver = webdriver.Chrome() # 传入浏览器对象 wait = WebDriverWait(driver, 5) # 显式等待 driver.get('https://qzone.qq.com/') driver.switch_to_frame('login_frame') #切换到登录窗口 input = wait.until(EC.presence_of_element_located((By.ID, 'switcher_plogin')))# 显式等待 找到账号密码登录按钮 time.sleep(1) input.click() # 交互点击 driver.find_element_by_id('u').clear() #清空里面的内容 driver.find_element_by_id('u').send_keys('your_qq') #传入你的QQ time.sleep(3) driver.find_element_by_id('p').clear() driver.find_element_by_id('p').send_keys('your_password') #传入你的密码 button = driver.find_element_by_id('login_button') #找到登录按钮 time.sleep(3) button.click() time.sleep(1) driver.switch_to.default_content() # 将frame重新定位回来，不然后续会出错 return driver 通过传回来的driver对象获取网页源代码和cookies 通过源代码获取qzonetoken参数1234def get_qzonetoken(html): paa = re.compile(r'window\.g_qzonetoken = \(function\(\)\&#123; try\&#123;return "(.*?)";\&#125; catch\(e\)', re.S) res = re.findall(paa, html)[0] # 因为返回的是列表形式，所以只取第一个元素 return res 注意：driver.get_cookies()获取的cookies是散的，所以要进行以下操作： 1234567891011def get_tk(cookie): #加密过程 hashes = 5381 for i in cookie['p_skey']: hashes += (hashes &lt;&lt; 5) + ord(i) return hashes &amp; 2147483647 cookies = driver.get_cookies() for item in cookies: cookie[item['name']] = item['value'] #将对应表达联系起来 # 上一步不懂的可以把 cookies的值输出来看一下 g_tk = get_tk(cookie) 3.将cookies传给requests,以保证都是在登录状态（最关键）12345678910111213141516171819def back_session(driver): mysession = requests.session() # 建立一个session对话 cookies = driver.get_cookies() cookie = &#123;&#125; for item in cookies: cookie[item['name']] = item['value'] headers = &#123; 'authority': 'user.qzone.qq.com', 'referer': 'https://qzone.qq.com/', 'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'accept-encoding': 'gzip, deflate, br', 'accept-language': 'zh-CN,zh;q=0.9', 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36' &#125; c = requests.utils.cookiejar_from_dict(cookie, cookiejar=None, overwrite=True) # 将字典转化为cookiejar形式 mysession.headers = headers # 请求头，防止反爬 mysession.cookies.update(c) # 更新cookies return mysession # 返回带cookies的requests 存入MySQL 12345678910connection = pymysql.connect(host='your_host', port=3306, user='你的账户', passwd='你的密码', db='your_database')connection.autocommit(True) #开启自动提交 不然每次执行def save_mysql(say, stime, QQ, connection): #这里我存入说说、说说时间、qq号 stime = str(stime) content = str(say) QQ = str(QQ) sql = 'insert into qq values ("&#123;&#125;","&#123;&#125;","&#123;&#125;")'.format(content, stime, QQ) connection.query(sql)# 数据库建表的时候 一定要把字符集改成utf8 看看效果图，爬了40多分钟，四万多条数据，有点小慢。。。，很慢。大家可以尝试下多线程爬取 完成以上步骤之后整个框架就都搭好了，其余数据的提取大家就先自己完成了吧（本文最后会给出GitHub地址），也希望大家看思路过后，自己操作，不仅仅是copy、paste and run 导出某个好友的数据库，用Notepad++过滤一些数据后，通过词云分析1234567891011121314151617181920212223242526272829303132import jiebafrom matplotlib import pyplot as pltfrom wordcloud import WordCloudfrom PIL import Imageimport numpy as nppath = r'your_data.text_path'font = r'C:\Windows\Fonts\simkai.TTF' # 字体pathtext = (open('C:/Users/hp/Desktop/233.txt', 'r', encoding='utf-8')).read() # 如果是中文的话encoding换成utf8cut = jieba.cut(text) # 分词string = ' '.join(cut)print(len(string))img = Image.open('your_photo_path') # 打开图片img_array = np.array(img) # 将图片装换为数组stopword = ['xa0'] # 设置停止词，也就是你不想显示的词，这里这个词是我前期处理没处理好，你可以删掉他看看他的作用wc = WordCloud( scale=4, #清晰度 background_color='white', #背景颜色 max_words=400, #最多单词 width=1000, height=800, mask=img_array, font_path=font, stopwords=stopword # 停用词)wc.generate_from_text(string) # 绘制图片plt.imshow(wc)plt.axis('off')plt.figure()#plt.show() # 显示图片wc.to_file('F:/3.png') # 保存图片 最后我么就分析到以下图片，字越大说明出现次数最多 最后贴上我的代码链接 https://github.com/Leaderzhangyi/QQspider 希望大家能够共同改进]]></content>
      <categories>
        <category>网络爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬楼梯问题路径保存及输出（DFS小白练习）]]></title>
    <url>%2F%E7%88%AC%E6%A5%BC%E6%A2%AFdfs.html</url>
    <content type="text"><![CDATA[大家最开始做爬楼梯问题肯定都是那个递归版本（斐波拉契数列），这次写这篇文章呢是因为浙江大学C++的一道课后练习题，顺便对dfs小白起一个练习作用，题意如下 废话不多说，直接上代码 我们先考虑没有步数限制的情况如何输出路径123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1000;int n,cnt;int a[maxn];void dfs(int sum,int step)&#123; if(sum == n) // 判断和是否和输入的n值相等 &#123; printf("%d",a[0]); for(int i = 1; i&lt;step; i++) &#123; printf("-%d",a[i]); &#125; printf("\n"); return ; &#125; for(int i = 1; i&lt;=3; i++) // 这里的i的范围是一步能走多少台阶 &#123; if(sum + i &lt;= n) &#123; a[cnt++] = i; dfs(sum+i,step+1); cnt--; // 返回上一层的时候 下标也要往后退一步 &#125; &#125;&#125;int main()&#123; while(~scanf("%d",&amp;n)) &#123; memset(a,0,sizeof(a)); // 初始化数组 cnt = 0; // 下标初始化 dfs(0,0); &#125; return 0;&#125; 步数限制版本1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int maxn = 1000;int n,cnt,temp,m;int a[maxn];void dfs(int sum,int step)&#123; if(sum == n &amp;&amp; step == m) // 步数限制加在判断里面就ok &#123; cout&lt;&lt;a[0]; for(int i = 1; i&lt;step; i++) &#123; cout&lt;&lt;"-"&lt;&lt;a[i]; &#125; cout&lt;&lt;endl; temp++; // 方法总数 return ; &#125; for(int i = 1; i&lt;=3; i++) &#123; if(sum + i &lt;= n) &#123; a[cnt++] = i; dfs(sum+i,step+1); cnt--; &#125; &#125;&#125;int main()&#123; while(~scanf("%d %d",&amp;n,&amp;m)) &#123; memset(a,0,sizeof(a)); cnt = temp = 0; dfs(0,0); cout&lt;&lt;"方法一共有 "&lt;&lt;temp&lt;&lt;" 种"&lt;&lt;endl; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
</search>
