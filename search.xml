<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[各类经典排序汇总(结合视频)]]></title>
    <url>%2F%E5%90%84%E7%B1%BB%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[各类基础排序汇总昨晚和几个ACM的朋友谈了会儿人生，原本危机感已经很强的我突然压力又大了起来😐，今天小程序全国晋级名单也没有我，反复扫了几遍还是没有，心一下凉了半截😌，不断学习进步才是王道呀。最近也在回顾数据结构，顺便自己也来总结一下几大经典排序算法。由于自己实力有限，若本文有任何纰漏或者大佬有什么好的建议，可以到底部留言区进行讨论与留言O(∩_∩)O 或通过右下角直接联系我噢 !! 所属类别graph TD A[排序] --> B{内部排序--使用内存}; B --> D(插入排序); D --> I(直接插入排序); D --> J(希尔排序); B --> E(选择排序); E --> K(简单选择排序); E --> L(堆排序); B --> F(交换排序); F --> M(冒泡排序); F --> N(快速排序); B --> G(归并排序); B --> H(基数排序->俗称桶排序); A --> C[外部排序--内存与外存相结合使用]; 各大排序的复杂度比较什么是稳定排序？ 待排序的记录序列中可能存在两个或两个以上关键字相等的记录。排序前的序列中Ri领先于Rj（即i&lt;j）.若在排序后的序列中Ri仍然领先于Rj，则称所用的方法是稳定的。 排序名称 平均时间复杂度 最好时间复杂度 最坏时间复杂度 空间复杂度 稳定性 建议 直接插入排序 O(N^2) O(N) [如果有序，那么每个元素都已经在在它的待排子序列的合适位置，不用找合适位置] O(N^2) O(1) 稳定 由于每次只能移动一位，建议使用希尔排序 希尔排序 O(N^1.3) O(N^2) O(N^2) O(1) 不稳定 选取合适的增量，一般选取为d = n/2，依次选下去，直到d为1 简单选择排序 O(N^2) O(N^2) O(N^2) O(1) 稳定 堆排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 不稳定 冒泡排序 O(N^2) O(N^2) O(N^2) O(1) 稳定 快速排序 O(nlog2n) O(nlog2n) O(N^2) O(nlog2n) [递归占用空间栈较多] 不稳定 归并排序 O(nlog2n) O(nlog2n) O(nlog2n) O(N) 稳定 但是这种算法很消耗空间，一般来说在内部排序不会用这种方法，而是用快速排序；外部排序才会考虑到使用这种方法 基数排序 O(D(N+R)) O(D(N+R)) O(D(N+R)) O(N+R) 稳定 各排序代码讲解贴一个排序在线动画演示，有兴趣的同学可以点进去加深印象 代码我用C来进行演示，算法重要的是思想，同学们可以尝试用自己的语言来实现 现在网络资源很多，并且好的讲解许多，关于一些排序的基本理论思想，我这给大家推荐几个视频通俗易懂 前人栽树，后人乘凉呀😁 简单排序 堆排序 归并排序 递归基础 插入排序：直接插入排序 InsertSort 主要核心理解：将一组序列分为有序和无序两个部分，每次将无序的元素在合适的index值插入到有序序列 123456789101112131415161718192021222324#include&lt;stdio.h&gt;int main()&#123; int n,a[50]; scanf("%d",&amp;n); for(int i = 0;i&lt;n;i++) &#123; scanf("%d",&amp;a[i]); &#125; for(int i = 1;i&lt;n;i++) // 从a[1]开始 因为a[0]一个数字默认有序 &#123; int key = a[i]; // 确立待插入的值 while(i &gt; 0 &amp;&amp; a[i-1] &gt; key) // 将key值与有序序列进行比较 &#123; a[i] = a[i-1]; // 前面的值往后移 i--; // 索引往前移，继续找合适的位置 &#125; a[i] = key; // 找到合适的位置了，将key插入到序列中 &#125; for(int i = 0;i&lt;n;i++) printf("%d%c",a[i],i==n-1?'\n':' '); return 0;&#125; 希尔排序 ShellSort 插入排序升级版，用增量解决直接插入排序的每次只能移动1位的缺点 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;int main()&#123; int n,a[50]; scanf("%d",&amp;n); for(int i = 0;i&lt;n;i++) &#123; scanf("%d",&amp;a[i]); &#125; int step; for(step = n/2;step &gt;= 1;step/=2) // 这里增量每次按一般取 &#123; for(int i = step;i&lt;n;i++) // 依次对按增量分类的序列进行插入排序 &#123; int j = i; int key = a[j]; while(j - step &gt;= 0 &amp;&amp; a[j-step] &gt; key) &#123; a[j] = a[j-step]; j = j - step; &#125; a[j] = key; &#125; &#125; for(int i = 0;i&lt;n;i++) printf("%d%c",a[i],i==n-1?'\n':' '); return 0;&#125; 选择排序：简单选择排序 SelectSort 每次在数组中找到最大（最小）的index值 然后与第一个值进行交换 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int main()&#123; int n,a[50]; scanf("%d",&amp;n); for(int i = 0;i&lt;n;i++) &#123; scanf("%d",&amp;a[i]); &#125; for(int i = 0;i&lt;n-1;i++) &#123; int index = i; for(int j = i+1;j&lt;n;j++) &#123; if(a[j] &gt; a[index]) &#123; index = j; &#125; &#125; int tmp = a[i]; a[i] = a[index]; a[index] = tmp; &#125; for(int i = 0;i&lt;n;i++) printf("%d%c",a[i],i==n-1?'\n':' '); return 0;&#125; 堆排序 HeapSort 其实就是利用堆这种数据结构，巧妙的进行排序，堆是一个近似完全二叉树的结构。 这里的思想见上面的堆排序视频讲解（up主讲解的通俗易懂，强烈推荐），我相信声音 + 图片的知识接收程度一定大于只看文字 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/// O(n*logn)#include&lt;stdio.h&gt;void swap(int tree[],int i,int j)&#123; int tmp = tree[i]; tree[i] = tree[j]; tree[j] = tmp;&#125;void heapify(int tree[],int n,int i)&#123; if(i&gt;=n) return; int c1 = 2*i+1; // 左节点 int c2 = 2*i+2; // 右节点 int max = i; if(c1 &lt; n &amp;&amp; tree[c1] &gt; tree[max]) &#123; max = c1; &#125; if(c2 &lt; n &amp;&amp; tree[c2] &gt; tree[max]) &#123; max = c2; &#125; if(max != i) // 若最大值的index与i不想等 就进行交换 &#123; swap(tree,max,i); heapify(tree,n,max); // 对当前最大值max节点进行递归 找出最大的值不断进行交换 &#125;&#125;void build_heap(int tree[],int n) &#123; int last_node = n - 1; int parent = (last_node - 1)/2; for(int i = parent; i &gt;= 0; i--) &#123; heapify(tree,n,i); &#125;&#125;void heap_sort(int tree[],int n)&#123; build_heap(tree,n); for(int i = n-1;i &gt;= 0;i--) &#123; swap(tree,i,0); // 最后一个节点与第一个节点交换（最小和最大的节点swap） heapify(tree,i,0); // 对最上面三个节点进行heapify 重新形成堆 这里n值用i来传 因为每次都会分离出最大值，所以节点数会每次递减1 &#125;&#125;int main()&#123; int n; int tree[50]; scanf("%d",&amp;n); for(int i = 0; i&lt;n; i++) scanf("%d",&amp;tree[i]); // heapify(tree,n,0); // build_heap(tree,n); heap_sort(tree,n); for(int i = 0; i&lt;n; i++) &#123; printf("%d%c",tree[i],i==n-1?'\n':' '); &#125; return 0;&#125; 交换排序：冒泡排序 冒泡，简单来说就是每次两两交换后都把把最大(最小)的值先放在最后面。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int main()&#123; int n,a[50]; scanf("%d",&amp;n); for(int i = 0;i&lt;n;i++) &#123; scanf("%d",&amp;a[i]); &#125; for(int i = 0;i&lt;n-1;i++) // 一共要排n-1次 &#123; /* 为什么是n-i-1呢？ 先不看减i 我们先看n-1 每次我们都是比较a[j]与a[j+1] 如果不减1 数组就会越界 再来看为什么减i 每排完一次序 就有1个最大或最小值排在最后面 所以每排了多少次 后面就应经有多少个有序的数字了 i值又是控制次数的 So每次要减i */ for(int j = 0;j&lt;n-i-1;j++) &#123; if(a[j] &gt; a[j+1]) &#123; int tmp = a[j]; a[j] = a[j + 1]; a[j+1] = tmp; &#125; &#125; &#125; for(int i = 0;i&lt;n;i++) printf("%d%c",a[i],i==n-1?'\n':' '); return 0;&#125; 快速排序 Quicksort 快速排序（Quicksort）是对冒泡排序的一种改进。不同的是，冒泡排序在每一轮只把一个元素冒泡到数列的一端，而快速排序在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成了两个部分。 我们可以看到这个动图，把大于6的分到一边，把小于6的分成一部分，再分别对这两部分进行相同的操作，直到还剩1个元素时，我们通过下面的例子来模拟一下 以一个实例模拟快速排序的过程: 设数组A为将要进行排序的数组 A=\{8,7,13,11,9,6,7,15,10,5\}快排的过程如下： 其中红色字体表示每一段子序列进行排序时所选择的基准元素，蓝色填充色的方块表示已经找到基准元素所处的位置。 从上图可以看出，每一个进行排序的序列都要经历三个过程：一是选择则基准元素（上述都选择第一个元素为基准元素），二是对基准元素进行寻址，三是将序列划分成两个子序列并重复上述的工作。 123456789101112131415161718192021222324252627282930313233343536373839404142/// O(n*logn ~ n*2)#include&lt;stdio.h&gt;void quickSort(int arr[],int l,int r)&#123; if(l &gt;= r) // 递归出口 说明只有一个元素时 回退 return; int k = arr[l]; int i,j; i = l; j = r; while(i != j) // 当左哨兵 和 右哨兵没有碰头时 进行两部分的交换 &#123; while(j&gt;i &amp;&amp; arr[j] &gt;= k) // 如果右边有比k大的就判断前一个值 否则就与哨兵i所在值进行交换 j--; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; while(i&lt;j &amp;&amp; arr[i] &lt;= k) // 如果左边有比k小的就判断后一个值 否则就与哨兵j所在值进行交换 i++; tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125; quickSort(arr,l,i-1); // 对左边递归 这里一个函数两个递归 如果不是理解很清楚的话 建议手动模拟一遍 若对递 归了解的不是很清晰 可以去之前推荐视频里看看 quickSort(arr,i+1,r); // 对右部分递归 &#125;int main()&#123; int arr[50]; int n; scanf("%d",&amp;n); for(int i = 0; i&lt;n; i++) &#123; scanf("%d",&amp;arr[i]); &#125; quickSort(arr,0,n-1); // 这里传的r和l都是索引值 for(int i = 0; i&lt;n; i++) printf("%d%c",arr[i],i==n-1?'\n':' '); return 0;&#125; 归并排序 MergeSort 归并和快排都用到了分治的思想 就是将原序列划分成两个等长子序列，再递归地排序这两个子序列，最后再调用归并操作合并成一个完整的有序数列 说白了就是 先分再合成有序 具体思想还是见上面的推荐视频 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;void merge(int arr[],int L,int R,int M)&#123; int LIET_SIZE = M - L ; int RIGHT_SIZE = R - M + 1; int lift[LIET_SIZE]; int right[RIGHT_SIZE]; int i,j,k; for(i = L;i &lt;=M ;i++) &#123; lift[i - L] = arr[i]; &#125; for(i = M;i&lt;=R;i++) &#123; right[i - M] = arr[i]; // printf("r = %d\n",right[i-M]); &#125; i = j = 0; k = L; while(i &lt; LIET_SIZE &amp;&amp; j &lt; RIGHT_SIZE) &#123; if(lift[i] &lt; right[j]) &#123; arr[k] = lift[i]; k++; i++; &#125; else &#123; arr[k] = right[j]; k++; j++; &#125; &#125; while(i &lt; LIET_SIZE) &#123; arr[k++] = lift[i]; i++; &#125; while(j &lt; RIGHT_SIZE) &#123; arr[k++] = right[j]; j++; &#125;&#125;void mergesort(int arr[],int L,int R)&#123; if(R == L) &#123; return; &#125; else&#123; int M = L + (R-L)/2; mergesort(arr,L,M); mergesort(arr,M+1,R); merge(arr,L,R,M+1); &#125;&#125;int main() &#123; int arr[10] = &#123;2,8,9,10,4,5,6,7&#125;; int R = 7; int L = 0; mergesort(arr,L,R); for(int i = 0;i&lt;8;i++) &#123; printf("%d ",arr[i]); &#125;&#125; 基数排序（不会，占时先留着）未完待续。。。]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整数分解为若干项之和(DFS小白入门)]]></title>
    <url>%2F%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3%E4%B8%BA%E8%8B%A5%E5%B9%B2%E9%A1%B9%E4%B9%8B%E5%92%8C.html</url>
    <content type="text"><![CDATA[整数分解为若干项之和(DFS小白入门)将一个正整数N分解成几个正整数相加，可以有多种分解方法，例如7=6+1，7=5+2，7=5+1+1，…。编程求出正整数N的所有整数分解式子。 输入格式：每个输入包含一个测试用例，即正整数N (0&lt;N≤30)。 输出格式：按递增顺序输出N的所有整数分解式子。递增顺序是指：对于两个分解序列N1={n1,n2,⋯}和N2={m1,m2,⋯}，若存在i使得n1=m1,⋯,n**i=m**i，但是n**i+1&lt;m**i+1,则N1序列必定在N2序列之前输出。每个式子由小到大相加，式子间用分号隔开，且每输出4个式子后换行。 输入样例：7 输出样例：7=1+1+1+1+1+1+1;7=1+1+1+1+1+2;7=1+1+1+1+3;7=1+1+1+2+2 7=1+1+1+4;7=1+1+2+3;7=1+1+5;7=1+2+2+2 7=1+2+4;7=1+3+3;7=1+6;7=2+2+3 7=2+5;7=3+4;7=7 看这种多种情况并且多种分解的 首先就要想到树 发现多种情况，和全排列有点像，果断DFS 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;#define MAX 500int a[MAX];int n;int cnt = 0,sum = 0;int k = 0;void DFS(int step)&#123; if(sum == n) // 总和与输入值相等时，进行输出 &#123; k++; printf("%d=",n); if(k%4 == 0 || a[cnt-1] == n) // 对格式进行适当的调整 &#123; for(int i = 0; i&lt;cnt; i++) &#123; printf("%d%c",a[i],i==cnt-1?'\n':'+'); &#125; &#125; else if(k%4) &#123; for(int i = 0; i&lt;cnt; i++) &#123; printf("%d%c",a[i],i==cnt-1?';':'+'); &#125; &#125; return; &#125; else if(sum &gt; n) return; for(int i = step; i&lt;=n; i++) &#123; a[cnt++] = i; sum += i; DFS(i); // 遍历下一个节点 sum -= i;// 回溯为上一个节点 所以要减去i cnt--; // 同样回溯 &#125;&#125;int main()&#123; scanf("%d",&amp;n); DFS(1); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[币值转换（模拟）]]></title>
    <url>%2F%E5%B8%81%E5%80%BC%E8%BD%AC%E6%8D%A2.html</url>
    <content type="text"><![CDATA[7-23 币值转换 (20 分) 输入一个整数（位数不超过9位）代表一个人民币值（单位为元），请转换成财务要求的大写中文格式。如23108元，转换后变成“贰万叁仟壹百零捌”元。为了简化输出，用小写英文字母a-j顺序代表大写数字0-9，用S、B、Q、W、Y分别代表拾、百、仟、万、亿。于是23108元应被转换输出为“cWdQbBai”元。 输入格式：输入在一行中给出一个不超过9位的非负整数。 输出格式：在一行中输出转换后的结果。注意“零”的用法必须符合中文习惯。 输入样例1：813227345 输出样例1：iYbQdBcScWhQdBeSf 输入样例2：6900 输出样例2：gQjB 作者: 陈建海 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;int main ()&#123; int n, initial_n; scanf("%d", &amp;n); initial_n = n; // 保留初始值 char num[10] = &#123;'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'&#125;; char unit[10] = &#123;0, 0, 'S', 'B', 'Q', 'W', 'S', 'B', 'Q', 'Y'&#125;;//舍弃前两位 char result[17]= &#123;0&#125;; // 9 位数最多有 17 位输出 int i = 0, last_i = n % 10; int j = 0; int count_n = 0; while (n &gt; 0) &#123; i = n % 10; n /= 10; count_n ++; if (i == 0 &amp;&amp; (count_n % 4) &gt; 1) // 从十位开始统计（个位0永远不输出） &#123; if (last_i != 0) // 如果前一位不等于 0，那就输出这个 0 &#123; result[j++] = num[i]; &#125; &#125; if (count_n == 5 &amp;&amp; i == 0 &amp;&amp; initial_n &lt; 100000000) &#123; result[j++] = unit[count_n]; // 万 w 是一定要输出的 &#125; if (count_n &gt; 1 &amp;&amp; i != 0) // 非 0 不输出单位 &#123; result[j++] = unit[count_n]; &#125; if (i != 0) // 处理非 0 数的输出 &#123; result[j++] = num[i]; &#125; last_i = i; //保留 i 的前一位的值 用于处理 0 &#125; if (initial_n == 0) // 处理特殊值 0 &#123; result[j++] = num[i]; &#125; for (j=j-1; j&gt;=0; j--) &#123; printf("%c", result[j]); &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux(redhat)安装gcc环境]]></title>
    <url>%2FLinux(redhat)%E5%AE%89%E8%A3%85gcc%E7%8E%AF%E5%A2%83%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%EF%BC%8C%E9%92%88%E5%AF%B9%E5%B0%8F%E7%99%BD%EF%BC%8C%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86%EF%BC%89.html</url>
    <content type="text"><![CDATA[前言：看来网上许多博客都是抄来抄去的基本一个样，还有许多坑，现在博主就来详细的介绍如何从无到有的在你的Linux环境里安装上gcc 注意:在配置gcc之前先把虚拟机的开机顺序调整正确！！！ 话不多说见图：如果不能点击就先关闭虚拟机在进行设置 现在开始 1.（先完成最上面那步再来做第一步）点击最上面的设备—&gt;分配光驱—&gt;选择你自己当前系统的.iso镜像文件选择好以后你桌面上就有一个光驱 2.开始进行挂载1）挂载光盘123cd /mntmkdir cdrommount /dev/cdrom /mnt/cdrom 2）进入软件包目录123cd /mnt/cdrom/Packagesls –la gcc*.*rpm –ivh gcc-4.4.7-3.el6.i686.rpm // 这里大家安装自己的版本(输入前几个关键字母后就用table键补齐) 不一定是我这写的版本 然后Enter进行安装，如果这安装出现问题不用管，直接进入第三步安装 3.安装以下rpm包 （从上到下依次安装，顺序一定不能乱！！）安装的时候名字不用全打,打了前面几个字母按table自动补全 注意：安装包的时候一定要根据自己包的版本安装，利用table键补齐。如果存在包的依赖关系报错的话，就先检查顺序是否正确，安装包的时候最好安装x84_64结尾的包 注意天坑: 在安装第4个rpm包的时候如果有图中红框的一定要选择图中方框这个包，不然后续会找不到对应的环境，如果没有的这个包的话还是安装i686.rpm结尾的！！！！ 12345678rpm -ivh kernel-headers-2.6.32-358.el6.i686.rpm rpm -ivh glibc-headers-2.12-1.107.el6.i686.rpm rpm -ivh glibc-devel-2.12-1.107.el6.i686.rpm rpm -ivh mpfr-2.4.1-6.el6.i686.rpm（依赖libmpfr.so.1） rpm -ivh cpp-4.4.7-3.el6.i686.rpm rpm -ivh ppl-0.10.2-11.el6.i686.rpm（依赖libppl.so.7和libppl_c.so.2）rpm -ivh cloog-ppl-0.15.7-1.2.el6.i686.rpm rpm -ivh gcc-4.4.7-3.el6.i686.rpm 4.安装好以后随便在一个文件夹中进行测试看是否成功我这是在根目录下面建了一个test文件夹 vim word.c进行编辑 在用gcc运行 大功告成，安装gcc成功，如果本文有什么错误或者知识点的遗漏欢迎大家指出！]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的询问（延时标记+差分）]]></title>
    <url>%2F%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%A2%E9%97%AE.html</url>
    <content type="text"><![CDATA[Problem A: 简单的询问Time Limit: 1 Sec Memory Limit: 64 MB Description给你N个区间[Li,Ri]，有Q个询问。 每个询问问，num这个数是否在给出的某个区间内。 Input输入第一行有一个正整数T(T&lt;=10)，表示组数； 每组数据第一行有两个正整数N,Q(N,Q]]></content>
      <categories>
        <category>算法</category>
        <category>差分数组</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Carryon 数数字(小米OJ)]]></title>
    <url>%2FCarryon%20%E6%95%B0%E6%95%B0%E5%AD%97.html</url>
    <content type="text"><![CDATA[Carryon 数数字序号：#138 难度：困难 时间限制：1000ms 内存限制：80M 描述Carryon 最近迷上了数数字，然后 Starry 给了他一个区间 [l,r] ,然后提了几个要求， 需要将 l 到 r 之间的数全部转化成 16 进制，然后连起来。 将连起来的数又转化成 10 进制。 将最终结果对 15 取模。 数据范围： $1&lt;=l&lt;=r&lt;=1000000000000$ 输入单组输入 l 和 r 的值 输出输出最终结果。 输入样例10 14 输出样例0 小提示如：10、11、12、13、14的16进制分别是a、b、c、d、e。依次连在一起是abcde，转换成10进制是703710，对15取模为0。 思路： 先看范围1~1e12 用普通for循环肯定超时，就要想怎么缩小范围，我们就先看取余 来看看为什么这里优化是 $c = a + (b - a)\%15$ 因为最后也要对15求余，我们就先对范围内取余来达到缩小范围这样也会保证结果相同以致不会超时1234567891011121314151617181920import sysfor line in sys.stdin: line = line.strip() a, b = map(int, line.split()) str = "" res = "" c = a + (b - a) % 15 # 先求个余 缩小范围 for i in range(a, c + 1): str += hex(i) # 每次加每个数的16进制 str = str.replace('0x', '') # 替换0x无用字符 for i in range(a, b + 1): ans = hex(i) res += ans res = res.replace('0x', '') print("优化前:" + res) print("优化后:" + str) print(int(str, 16) % 15) # 再从16进制转10进制取余 看下结果 123456789101112131415161718191 16优化前:123456789abcdef10优化后:111 99优化前:123456789abcdef101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f60616263优化后:123456789010 14优化前:abcde优化后:abcde02 21优化前:23456789abcdef101112131415优化后:234565 12345678910import sysfor line in sys.stdin: line = line.strip() a,b= line.split() str = "" c = int(a) + (int(b)-int(a)) % 15 # 先求个余 缩小范围 for i in range(int(a), int(c)+1): str += hex(i) # 每次加每个数的16进制 str = str.replace('0x', '') # 替换0x无用字符 print(int(str, 16) % 15) # 再从16进制转10进制取余]]></content>
      <categories>
        <category>算法</category>
        <category>取余优化</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python单线程爬取QQ空间说说存入MySQL并生成词云（超详细讲解，踩坑经历）]]></title>
    <url>%2Fpython.html</url>
    <content type="text"><![CDATA[利用python爬取好友说说并分析 看了网上的许多博客，基本上都是一个样，基本的知识也没详细解释，我这次也想跟大家仔细分析一下，自己还是要有一定爬虫基础，本人技术有限，如果本文哪有错误或不够准确的地方，还望大牛们指点ヾ(๑╹◡╹)ﾉ” 一、环境配置： Python 3.6 selenium (注意:先配置好自己浏览器的驱动，下载地址看下面) pymysql re requests 点击下载chrome的——&gt;Chrome_webdriver点击下载Firefox的——&gt;Firefox_webdriver点击下载IE的——&gt;IE_webdriver 先来张效果图看看效果 二、思路： 作为一个菜鸡学了一点爬虫，就想做一个好友的说说分析，最开始我以为这个爬虫很简单几十行就可以搞定，然而忽略了一些东西。。。。（先卖个关子） 先说说整个过程的想法： 看起来是不是很简单？（手动dog）那现在我们就来按步骤操作一下 1.找到包含好友的QQ信息的url（这里也有两种方法） 法一：先点开好友这一栏,通过亲密度的排行来获取，这里我们点开F12，选中Network一般这种信息都在XHR或者JS类型里面，大家可以在这里面找找，通过一会的寻找我们就发现friend_ship开头这xhr里面的items_list就包含了好友的QQ号和姓名，但是此方法获取的qq不全，只是大部分的qq 法二：点击页面最上面的设置按钮，滑动可见好友，通过js的结果分析，随着下滑请求的url的页数都在变化，我们只要每次修改下页数的参数就可以获取所有好友的QQ，这个方法可以获取所有的好友的qq，但对于qq好友很少的朋友来说，此方法不适用 2.找到包含好友的说说的url我们先随便点进一个好友的空间进行分析点进去过后，我们F12 进行分析，发现一页最多存20条说说，以此我们可以通过说说总数（re提取）来算出一共有多少页，然后通过构造url来获取 通过以上的分析过后我们开始获取url： 我们先看看获取qq的第一种方法的url：&gt; https://user.qzone.qq.com/proxy/domain/r.qzone.qq.com/cgi-bin/tfriend/friend_ship_manager.cgi?uin=你的QQ号&amp;do=1&amp;rd=0.55484478707938&amp;fupdate=1&amp;clean=1&amp;g_tk=1376935160&amp;qzonetoken=6e4e0b063e3f00421d98df35b330c8bb2158bb8697e5dc7a85a65b379407706960f0b1c422f9a26879&amp;g_tk=1376935160 我们分析一下这里面每次登录都在变的参数 g_tk （空间加密算法） qzonetoken （空间源码里面的参数） 那这两个参数我们要怎么获取呢？为什么每次登录这两个参数的都在变呢？ 我们首先先要了解一下——&gt;cookie在看看session的基本概念 快速查看 cookies 的方法：按F12进入浏览器的开发者模式——console——在命令行输入javascript:alert(document.cookie)，再回车即可看见 所以我们登录过后，每次都访问url的时候都要保持着参数不变，也就是说cookie不能变每次都要是同一个cookie(就相当于每次都是以你的身份保持着登录状态去访问他人空间)，否则就会出现以下情况↓ 理解好以上的几个问题过后，问题就解决了一大部分了接着我们分析g_tk参数，在自己qq空间主页 F12 点JS类型文件，找到以下文件,查看Preview部分，分析一下其中的代码 其实这个程序的意思， 还是直接上代码吧1234567891011def get_tk(cookie): hashes = 5381 for i in cookie['p_skey']: #提取cookie中p_skey每个字母 hashes += (hashes &lt;&lt; 5) + ord(i) #加密过程,ord()将 字符转化为ASCII码 # &lt;&lt; 二进制 左移运算 左移几位就相当于乘以2的几次方 return hashes &amp; 2147483647 #二进制 与运算 # 比如 2&amp;3 转为二进制 10&amp;11 # 都是1结果为1，否则为0 # 所以二进制算出来是 10 返回2 # 还不懂的朋友，还是自行Baidu吧 随着我们分析第二个参数qzonetoken这个参数很好获取，在我们空间主页右键查看网页源代码,Ctrl+F查找下可以找到，之后我们可以通过正则提取ok，理解了上面的全部，基本就完成了80%了，接下来我们开始代码实现 三、代码实现：先导入第三方库1234567import re, requestsimport time, pymysqlfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as EC 首先是登录，我们这里用selenium模拟浏览器实现 1234567891011121314151617181920def login(): driver = webdriver.Chrome() # 传入浏览器对象 wait = WebDriverWait(driver, 5) # 显式等待 driver.get('https://qzone.qq.com/') driver.switch_to_frame('login_frame') #切换到登录窗口 input = wait.until(EC.presence_of_element_located((By.ID, 'switcher_plogin')))# 显式等待 找到账号密码登录按钮 time.sleep(1) input.click() # 交互点击 driver.find_element_by_id('u').clear() #清空里面的内容 driver.find_element_by_id('u').send_keys('your_qq') #传入你的QQ time.sleep(3) driver.find_element_by_id('p').clear() driver.find_element_by_id('p').send_keys('your_password') #传入你的密码 button = driver.find_element_by_id('login_button') #找到登录按钮 time.sleep(3) button.click() time.sleep(1) driver.switch_to.default_content() # 将frame重新定位回来，不然后续会出错 return driver 通过传回来的driver对象获取网页源代码和cookies 通过源代码获取qzonetoken参数1234def get_qzonetoken(html): paa = re.compile(r'window\.g_qzonetoken = \(function\(\)\&#123; try\&#123;return "(.*?)";\&#125; catch\(e\)', re.S) res = re.findall(paa, html)[0] # 因为返回的是列表形式，所以只取第一个元素 return res 注意：driver.get_cookies()获取的cookies是散的，所以要进行以下操作： 1234567891011def get_tk(cookie): #加密过程 hashes = 5381 for i in cookie['p_skey']: hashes += (hashes &lt;&lt; 5) + ord(i) return hashes &amp; 2147483647 cookies = driver.get_cookies() for item in cookies: cookie[item['name']] = item['value'] #将对应表达联系起来 # 上一步不懂的可以把 cookies的值输出来看一下 g_tk = get_tk(cookie) 3.将cookies传给requests,以保证都是在登录状态（最关键）12345678910111213141516171819def back_session(driver): mysession = requests.session() # 建立一个session对话 cookies = driver.get_cookies() cookie = &#123;&#125; for item in cookies: cookie[item['name']] = item['value'] headers = &#123; 'authority': 'user.qzone.qq.com', 'referer': 'https://qzone.qq.com/', 'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'accept-encoding': 'gzip, deflate, br', 'accept-language': 'zh-CN,zh;q=0.9', 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36' &#125; c = requests.utils.cookiejar_from_dict(cookie, cookiejar=None, overwrite=True) # 将字典转化为cookiejar形式 mysession.headers = headers # 请求头，防止反爬 mysession.cookies.update(c) # 更新cookies return mysession # 返回带cookies的requests 存入MySQL 12345678910connection = pymysql.connect(host='your_host', port=3306, user='你的账户', passwd='你的密码', db='your_database')connection.autocommit(True) #开启自动提交 不然每次执行def save_mysql(say, stime, QQ, connection): #这里我存入说说、说说时间、qq号 stime = str(stime) content = str(say) QQ = str(QQ) sql = 'insert into qq values ("&#123;&#125;","&#123;&#125;","&#123;&#125;")'.format(content, stime, QQ) connection.query(sql)# 数据库建表的时候 一定要把字符集改成utf8 看看效果图，爬了40多分钟，四万多条数据，有点小慢。。。，很慢。大家可以尝试下多线程爬取 完成以上步骤之后整个框架就都搭好了，其余数据的提取大家就先自己完成了吧（本文最后会给出GitHub地址），也希望大家看思路过后，自己操作，不仅仅是copy、paste and run 导出某个好友的数据库，用Notepad++过滤一些数据后，通过词云分析1234567891011121314151617181920212223242526272829303132import jiebafrom matplotlib import pyplot as pltfrom wordcloud import WordCloudfrom PIL import Imageimport numpy as nppath = r'your_data.text_path'font = r'C:\Windows\Fonts\simkai.TTF' # 字体pathtext = (open('C:/Users/hp/Desktop/233.txt', 'r', encoding='utf-8')).read() # 如果是中文的话encoding换成utf8cut = jieba.cut(text) # 分词string = ' '.join(cut)print(len(string))img = Image.open('your_photo_path') # 打开图片img_array = np.array(img) # 将图片装换为数组stopword = ['xa0'] # 设置停止词，也就是你不想显示的词，这里这个词是我前期处理没处理好，你可以删掉他看看他的作用wc = WordCloud( scale=4, #清晰度 background_color='white', #背景颜色 max_words=400, #最多单词 width=1000, height=800, mask=img_array, font_path=font, stopwords=stopword # 停用词)wc.generate_from_text(string) # 绘制图片plt.imshow(wc)plt.axis('off')plt.figure()#plt.show() # 显示图片wc.to_file('F:/3.png') # 保存图片 最后我么就分析到以下图片，字越大说明出现次数最多 最后贴上我的代码链接 https://github.com/Leaderzhangyi/QQspider 希望大家能够共同改进]]></content>
      <categories>
        <category>网络爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬楼梯问题路径保存及输出（DFS小白练习）]]></title>
    <url>%2F%E7%88%AC%E6%A5%BC%E6%A2%AFdfs.html</url>
    <content type="text"><![CDATA[大家最开始做爬楼梯问题肯定都是那个递归版本（斐波拉契数列），这次写这篇文章呢是因为浙江大学C++的一道课后练习题，顺便对dfs小白起一个练习作用，题意如下 废话不多说，直接上代码 我们先考虑没有步数限制的情况如何输出路径123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1000;int n,cnt;int a[maxn];void dfs(int sum,int step)&#123; if(sum == n) // 判断和是否和输入的n值相等 &#123; printf("%d",a[0]); for(int i = 1; i&lt;step; i++) &#123; printf("-%d",a[i]); &#125; printf("\n"); return ; &#125; for(int i = 1; i&lt;=3; i++) // 这里的i的范围是一步能走多少台阶 &#123; if(sum + i &lt;= n) &#123; a[cnt++] = i; dfs(sum+i,step+1); cnt--; // 返回上一层的时候 下标也要往后退一步 &#125; &#125;&#125;int main()&#123; while(~scanf("%d",&amp;n)) &#123; memset(a,0,sizeof(a)); // 初始化数组 cnt = 0; // 下标初始化 dfs(0,0); &#125; return 0;&#125; 步数限制版本1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int maxn = 1000;int n,cnt,temp,m;int a[maxn];void dfs(int sum,int step)&#123; if(sum == n &amp;&amp; step == m) // 步数限制加在判断里面就ok &#123; cout&lt;&lt;a[0]; for(int i = 1; i&lt;step; i++) &#123; cout&lt;&lt;"-"&lt;&lt;a[i]; &#125; cout&lt;&lt;endl; temp++; // 方法总数 return ; &#125; for(int i = 1; i&lt;=3; i++) &#123; if(sum + i &lt;= n) &#123; a[cnt++] = i; dfs(sum+i,step+1); cnt--; &#125; &#125;&#125;int main()&#123; while(~scanf("%d %d",&amp;n,&amp;m)) &#123; memset(a,0,sizeof(a)); cnt = temp = 0; dfs(0,0); cout&lt;&lt;"方法一共有 "&lt;&lt;temp&lt;&lt;" 种"&lt;&lt;endl; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
</search>
