<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[币值转换（模拟）]]></title>
    <url>%2F%E5%B8%81%E5%80%BC%E8%BD%AC%E6%8D%A2.html</url>
    <content type="text"><![CDATA[7-23 币值转换 (20 分) 输入一个整数（位数不超过9位）代表一个人民币值（单位为元），请转换成财务要求的大写中文格式。如23108元，转换后变成“贰万叁仟壹百零捌”元。为了简化输出，用小写英文字母a-j顺序代表大写数字0-9，用S、B、Q、W、Y分别代表拾、百、仟、万、亿。于是23108元应被转换输出为“cWdQbBai”元。 输入格式：输入在一行中给出一个不超过9位的非负整数。 输出格式：在一行中输出转换后的结果。注意“零”的用法必须符合中文习惯。 输入样例1：813227345输出样例1：iYbQdBcScWhQdBeSf输入样例2：6900输出样例2：gQjB 作者: 陈建海 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;int main ()&#123; int n, initial_n; scanf("%d", &amp;n); initial_n = n; // 保留初始值 char num[10] = &#123;'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'&#125;; char unit[10] = &#123;0, 0, 'S', 'B', 'Q', 'W', 'S', 'B', 'Q', 'Y'&#125;;//舍弃前两位 char result[17]= &#123;0&#125;; // 9 位数最多有 17 位输出 int i, last_i = n % 10; int j = 0; int count_n = 0; while (n &gt; 0) &#123; i = n % 10; n /= 10; count_n ++; if (i == 0 &amp;&amp; (count_n % 4) &gt; 1) // 从十位开始统计（个位0永远不输出） &#123; if (last_i != 0) // 如果前一位不等于 0，那就输出这个 0 &#123; result[j++] = num[i]; &#125; &#125; if (count_n == 5 &amp;&amp; i == 0 &amp;&amp; initial_n &lt; 100000000) &#123; result[j++] = unit[count_n]; // 万 w 是一定要输出的 &#125; if (count_n &gt; 1 &amp;&amp; i != 0) // 非 0 不输出单位 &#123; result[j++] = unit[count_n]; &#125; if (i != 0) // 处理非 0 数的输出 &#123; result[j++] = num[i]; &#125; last_i = i; //保留 i 的前一位的值 用于处理 0 &#125; if (initial_n == 0) // 处理特殊值 0 &#123; result[j++] = num[i]; &#125; for (j=j-1; j&gt;=0; j--) &#123; printf("%c", result[j]); &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux(redhat)安装gcc环境]]></title>
    <url>%2FLinux(redhat)%E5%AE%89%E8%A3%85gcc%E7%8E%AF%E5%A2%83%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%EF%BC%8C%E9%92%88%E5%AF%B9%E5%B0%8F%E7%99%BD%EF%BC%8C%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86%EF%BC%89.html</url>
    <content type="text"><![CDATA[前言：看来网上许多博客都是抄来抄去的基本一个样，还有许多坑，现在博主就来详细的介绍如何从无到有的在你的Linux环境里安装上gcc 注意:在配置gcc之前先把虚拟机的开机顺序调整正确！！！ 话不多说见图：如果不能点击就先关闭虚拟机在进行设置 现在开始 1.（先完成最上面那步再来做第一步）点击最上面的设备–&gt;分配光驱–&gt;选择你自己当前系统的.iso镜像文件选择好以后你桌面上就有一个光驱 2.开始进行挂载1）挂载光盘 123cd /mntmkdir cdrommount /dev/cdrom /mnt/cdrom 2）进入软件包目录 123cd /mnt/cdrom/Packagesls –la gcc*.*rpm –ivh gcc-4.4.7-3.el6.i686.rpm // 这里大家安装自己的版本(输入前几个关键字母后就用table键补齐) 不一定是我这写的版本 然后Enter进行安装，如果这安装出现问题不用管，直接进入第三步安装 3.安装以下rpm包 （从上到下依次安装，顺序一定不能乱！！）安装的时候名字不用全打,打了前面几个字母按table自动补全 注意：安装包的时候一定要根据自己包的版本安装，利用table键补齐。如果存在包的依赖关系报错的话，就先检查顺序是否正确，安装包的时候最好安装x84_64结尾的包 注意天坑: 在安装第4个rpm包的时候如果有图中红框的一定要选择图中方框这个包，不然后续会找不到对应的环境，如果没有的这个包的话还是安装i686.rpm结尾的！！！！ 12345678rpm -ivh kernel-headers-2.6.32-358.el6.i686.rpm rpm -ivh glibc-headers-2.12-1.107.el6.i686.rpm rpm -ivh glibc-devel-2.12-1.107.el6.i686.rpm rpm -ivh mpfr-2.4.1-6.el6.i686.rpm（依赖libmpfr.so.1） rpm -ivh cpp-4.4.7-3.el6.i686.rpm rpm -ivh ppl-0.10.2-11.el6.i686.rpm（依赖libppl.so.7和libppl_c.so.2）rpm -ivh cloog-ppl-0.15.7-1.2.el6.i686.rpm rpm -ivh gcc-4.4.7-3.el6.i686.rpm 4.安装好以后随便在一个文件夹中进行测试看是否成功我这是在根目录下面建了一个test文件夹 vim word.c进行编辑 在用gcc运行 大功告成，安装gcc成功，如果本文有什么错误或者知识点的遗漏欢迎大家指出！]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的询问（延时标记+差分）]]></title>
    <url>%2F%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%A2%E9%97%AE.html</url>
    <content type="text"><![CDATA[Problem A: 简单的询问Time Limit: 1 Sec Memory Limit: 64 MB Description给你N个区间[Li,Ri]，有Q个询问。 每个询问问，num这个数是否在给出的某个区间内。 Input输入第一行有一个正整数T(T&lt;=10)，表示组数； 每组数据第一行有两个正整数N,Q(N,Q&lt;=1e5)，意义如题； 接下来行每行包含两个正整数Li,Ri(Li&lt;=Ri&lt;=1e6)，意义如题； 接下来行每行包含一个整数num(int范围内)，意义如题。 Output对于每个询问，如果num在区间内则输出Yes，否则输出No。 Sample Input14 51 32 44 57 8246810 Sample OutputYesYesNoYesNo HINT之前这道题还是卡了很久，只想到了延时标记，但没想到差分数组(该补补啦) ———————————————————————————————————————差分数组不仅仅是一个优秀的数据结构，还是一种很好的思想差分数组的功能是修改区间，查询点修改区间的时间复杂度是O（1），查询点的时间复杂度为O（n）我们这里要根据数据范围灵活选取方法，不要拘泥于差分数组这里给大家推荐一篇比较好的博客 http://www.cnblogs.com/aininot260/p/9304521.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;using namespace std;const int maxn = 1e6 + 20;int vis[maxn];int sum[maxn];int main()&#123; int n, m, t; scanf("%d", &amp;t); while (t--) &#123; memset(vis, 0, sizeof vis); memset(sum, 0, sizeof sum); scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int l, r; scanf("%d %d", &amp;l, &amp;r); vis[l] += 1; vis[r + 1] -= 1; //延迟标记（不懂的自行百度） &#125; for (int i = 1; i &lt;= 1000000 + 10; i++) //注意范围 &#123; sum[i] = sum[i - 1] + vis[i]; //用另一个数组存 &#125; for (int i = 1; i &lt;= m; i++) &#123; int x; scanf("%d", &amp;x); if (x&lt;0 || x&gt;1e6) //根据题上的要求 把脏数去掉 不然会RE &#123; printf("No\n"); &#125; else &#123; if (sum[x] != 0) //判断是否区间延迟标记了 &#123; printf("Yes\n"); &#125; else &#123; printf("No\n"); &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>差分数组</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Carryon 数数字(小米OJ)]]></title>
    <url>%2FCarryon%20%E6%95%B0%E6%95%B0%E5%AD%97.html</url>
    <content type="text"><![CDATA[Carryon 数数字序号：#138 难度：困难 时间限制：1000ms 内存限制：80M 描述Carryon 最近迷上了数数字，然后 Starry 给了他一个区间 [l,r] ,然后提了几个要求， 需要将 l 到 r 之间的数全部转化成 16 进制，然后连起来。 将连起来的数又转化成 10 进制。 将最终结果对 15 取模。 数据范围： $1&lt;=l&lt;=r&lt;=1000000000000$ 输入单组输入 l 和 r 的值 输出输出最终结果。 输入样例10 14 输出样例0 小提示如：10、11、12、13、14的16进制分别是a、b、c、d、e。依次连在一起是abcde，转换成10进制是703710，对15取模为0。 思路： 先看范围1~1e12 用普通for循环肯定超时，就要想怎么缩小范围，我们就先看取余 来看看为什么这里优化是 $c = a + (b - a)%15$ 因为最后也要对15求余，我们就先对范围内取余来达到缩小范围这样也会保证结果相同以致不会超时1234567891011121314151617181920import sysfor line in sys.stdin: line = line.strip() a, b = map(int, line.split()) str = "" res = "" c = a + (b - a) % 15 # 先求个余 缩小范围 for i in range(a, c + 1): str += hex(i) # 每次加每个数的16进制 str = str.replace('0x', '') # 替换0x无用字符 for i in range(a, b + 1): ans = hex(i) res += ans res = res.replace('0x', '') print("优化前:" + res) print("优化后:" + str) print(int(str, 16) % 15) # 再从16进制转10进制取余 看下结果 123456789101112131415161718191 16优化前:123456789abcdef10优化后:111 99优化前:123456789abcdef101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f60616263优化后:123456789010 14优化前:abcde优化后:abcde02 21优化前:23456789abcdef101112131415优化后:234565 12345678910import sysfor line in sys.stdin: line = line.strip() a,b= line.split() str = "" c = int(a) + (int(b)-int(a)) % 15 # 先求个余 缩小范围 for i in range(int(a), int(c)+1): str += hex(i) # 每次加每个数的16进制 str = str.replace('0x', '') # 替换0x无用字符 print(int(str, 16) % 15) # 再从16进制转10进制取余]]></content>
      <categories>
        <category>算法</category>
        <category>取余优化</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python单线程爬取QQ空间说说存入MySQL并生成词云（超详细讲解，踩坑经历）]]></title>
    <url>%2Fpython.html</url>
    <content type="text"><![CDATA[利用python爬取好友说说并分析 看了网上的许多博客，基本上都是一个样，基本的知识也没详细解释，我这次也想跟大家仔细分析一下，自己还是要有一定爬虫基础，本人技术有限，如果本文哪有错误或不够准确的地方，还望大牛们指点ヾ(๑╹◡╹)ﾉ” 一、环境配置： Python 3.6 selenium (注意:先配置好自己浏览器的驱动，下载地址看下面) pymysql re requests 点击下载chrome的—-&gt;Chrome_webdriver点击下载Firefox的—-&gt;Firefox_webdriver点击下载IE的—-&gt;IE_webdriver 先来张效果图看看效果 二、思路： 作为一个菜鸡学了一点爬虫，就想做一个好友的说说分析，最开始我以为这个爬虫很简单几十行就可以搞定，然而忽略了一些东西。。。。（先卖个关子） 先说说整个过程的想法： 看起来是不是很简单？（手动dog）那现在我们就来按步骤操作一下 1.找到包含好友的QQ信息的url（这里也有两种方法） 法一：先点开好友这一栏,通过亲密度的排行来获取，这里我们点开F12，选中Network一般这种信息都在XHR或者JS类型里面，大家可以在这里面找找，通过一会的寻找我们就发现friend_ship开头这xhr里面的items_list就包含了好友的QQ号和姓名，但是此方法获取的qq不全，只是大部分的qq 法二：点击页面最上面的设置按钮，滑动可见好友，通过js的结果分析，随着下滑请求的url的页数都在变化，我们只要每次修改下页数的参数就可以获取所有好友的QQ，这个方法可以获取所有的好友的qq，但对于qq好友很少的朋友来说，此方法不适用 2.找到包含好友的说说的url我们先随便点进一个好友的空间进行分析点进去过后，我们F12 进行分析，发现一页最多存20条说说，以此我们可以通过说说总数（re提取）来算出一共有多少页，然后通过构造url来获取 通过以上的分析过后我们开始获取url： 我们先看看获取qq的第一种方法的url： https://user.qzone.qq.com/proxy/domain/r.qzone.qq.com/cgi-bin/tfriend/friend_ship_manager.cgi?uin=你的QQ号&amp;do=1&amp;rd=0.55484478707938&amp;fupdate=1&amp;clean=1&amp;g_tk=1376935160&amp;qzonetoken=6e4e0b063e3f00421d98df35b330c8bb2158bb8697e5dc7a85a65b379407706960f0b1c422f9a26879&amp;g_tk=1376935160 我们分析一下这里面每次登录都在变的参数 g_tk （空间加密算法） qzonetoken （空间源码里面的参数） 那这两个参数我们要怎么获取呢？为什么每次登录这两个参数的都在变呢？ 我们首先先要了解一下—-&gt;cookie在看看session的基本概念 快速查看 cookies 的方法：按F12进入浏览器的开发者模式——console——在命令行输入javascript:alert(document.cookie)，再回车即可看见 所以我们登录过后，每次都访问url的时候都要保持着参数不变，也就是说cookie不能变每次都要是同一个cookie(就相当于每次都是以你的身份保持着登录状态去访问他人空间)，否则就会出现以下情况↓ 理解好以上的几个问题过后，问题就解决了一大部分了接着我们分析g_tk参数，在自己qq空间主页 F12 点JS类型文件，找到以下文件,查看Preview部分，分析一下其中的代码 其实这个程序的意思， 还是直接上代码吧 1234567891011def get_tk(cookie): hashes = 5381 for i in cookie['p_skey']: #提取cookie中p_skey每个字母 hashes += (hashes &lt;&lt; 5) + ord(i) #加密过程,ord()将 字符转化为ASCII码 # &lt;&lt; 二进制 左移运算 左移几位就相当于乘以2的几次方 return hashes &amp; 2147483647 #二进制 与运算 # 比如 2&amp;3 转为二进制 10&amp;11 # 都是1结果为1，否则为0 # 所以二进制算出来是 10 返回2 # 还不懂的朋友，还是自行Baidu吧 随着我们分析第二个参数qzonetoken这个参数很好获取，在我们空间主页右键查看网页源代码,Ctrl+F查找下可以找到，之后我们可以通过正则提取ok，理解了上面的全部，基本就完成了80%了，接下来我们开始代码实现 三、代码实现：先导入第三方库 1234567import re, requestsimport time, pymysqlfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as EC 首先是登录，我们这里用selenium模拟浏览器实现 1234567891011121314151617181920def login(): driver = webdriver.Chrome() # 传入浏览器对象 wait = WebDriverWait(driver, 5) # 显式等待 driver.get('https://qzone.qq.com/') driver.switch_to_frame('login_frame') #切换到登录窗口 input = wait.until(EC.presence_of_element_located((By.ID, 'switcher_plogin')))# 显式等待 找到账号密码登录按钮 time.sleep(1) input.click() # 交互点击 driver.find_element_by_id('u').clear() #清空里面的内容 driver.find_element_by_id('u').send_keys('your_qq') #传入你的QQ time.sleep(3) driver.find_element_by_id('p').clear() driver.find_element_by_id('p').send_keys('your_password') #传入你的密码 button = driver.find_element_by_id('login_button') #找到登录按钮 time.sleep(3) button.click() time.sleep(1) driver.switch_to.default_content() # 将frame重新定位回来，不然后续会出错 return driver 通过传回来的driver对象获取网页源代码和cookies 通过源代码获取qzonetoken参数 1234def get_qzonetoken(html): paa = re.compile(r'window\.g_qzonetoken = \(function\(\)\&#123; try\&#123;return "(.*?)";\&#125; catch\(e\)', re.S) res = re.findall(paa, html)[0] # 因为返回的是列表形式，所以只取第一个元素 return res 注意：driver.get_cookies()获取的cookies是散的，所以要进行以下操作： 1234567891011def get_tk(cookie): #加密过程 hashes = 5381 for i in cookie['p_skey']: hashes += (hashes &lt;&lt; 5) + ord(i) return hashes &amp; 2147483647 cookies = driver.get_cookies() for item in cookies: cookie[item['name']] = item['value'] #将对应表达联系起来 # 上一步不懂的可以把 cookies的值输出来看一下 g_tk = get_tk(cookie) 3.将cookies传给requests,以保证都是在登录状态（最关键） 12345678910111213141516171819def back_session(driver): mysession = requests.session() # 建立一个session对话 cookies = driver.get_cookies() cookie = &#123;&#125; for item in cookies: cookie[item['name']] = item['value'] headers = &#123; 'authority': 'user.qzone.qq.com', 'referer': 'https://qzone.qq.com/', 'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'accept-encoding': 'gzip, deflate, br', 'accept-language': 'zh-CN,zh;q=0.9', 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36' &#125; c = requests.utils.cookiejar_from_dict(cookie, cookiejar=None, overwrite=True) # 将字典转化为cookiejar形式 mysession.headers = headers # 请求头，防止反爬 mysession.cookies.update(c) # 更新cookies return mysession # 返回带cookies的requests 存入MySQL 12345678910connection = pymysql.connect(host='your_host', port=3306, user='你的账户', passwd='你的密码', db='your_database')connection.autocommit(True) #开启自动提交 不然每次执行def save_mysql(say, stime, QQ, connection): #这里我存入说说、说说时间、qq号 stime = str(stime) content = str(say) QQ = str(QQ) sql = 'insert into qq values ("&#123;&#125;","&#123;&#125;","&#123;&#125;")'.format(content, stime, QQ) connection.query(sql)# 数据库建表的时候 一定要把字符集改成utf8 看看效果图，爬了40多分钟，四万多条数据，有点小慢。。。，很慢。大家可以尝试下多线程爬取 完成以上步骤之后整个框架就都搭好了，其余数据的提取大家就先自己完成了吧（本文最后会给出GitHub地址），也希望大家看思路过后，自己操作，不仅仅是copy、paste and run 导出某个好友的数据库，用Notepad++过滤一些数据后，通过词云分析 1234567891011121314151617181920212223242526272829303132import jiebafrom matplotlib import pyplot as pltfrom wordcloud import WordCloudfrom PIL import Imageimport numpy as nppath = r'your_data.text_path'font = r'C:\Windows\Fonts\simkai.TTF' # 字体pathtext = (open('C:/Users/hp/Desktop/233.txt', 'r', encoding='utf-8')).read() # 如果是中文的话encoding换成utf8cut = jieba.cut(text) # 分词string = ' '.join(cut)print(len(string))img = Image.open('your_photo_path') # 打开图片img_array = np.array(img) # 将图片装换为数组stopword = ['xa0'] # 设置停止词，也就是你不想显示的词，这里这个词是我前期处理没处理好，你可以删掉他看看他的作用wc = WordCloud( scale=4, #清晰度 background_color='white', #背景颜色 max_words=400, #最多单词 width=1000, height=800, mask=img_array, font_path=font, stopwords=stopword # 停用词)wc.generate_from_text(string) # 绘制图片plt.imshow(wc)plt.axis('off')plt.figure()#plt.show() # 显示图片wc.to_file('F:/3.png') # 保存图片 最后我么就分析到以下图片，字越大说明出现次数最多 最后贴上我的代码链接 https://github.com/Leaderzhangyi/QQspider 希望大家能够共同改进]]></content>
      <categories>
        <category>网络爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬楼梯问题路径保存及输出（DFS小白练习）]]></title>
    <url>%2F%E7%88%AC%E6%A5%BC%E6%A2%AFdfs.html</url>
    <content type="text"><![CDATA[大家最开始做爬楼梯问题肯定都是那个递归版本（斐波拉契数列），这次写这篇文章呢是因为浙江大学C++的一道课后练习题，顺便对dfs小白起一个练习作用，题意如下 废话不多说，直接上代码 我们先考虑没有步数限制的情况如何输出路径 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1000;int n,cnt;int a[maxn];void dfs(int sum,int step)&#123; if(sum == n) // 判断和是否和输入的n值相等 &#123; printf("%d",a[0]); for(int i = 1; i&lt;step; i++) &#123; printf("-%d",a[i]); &#125; printf("\n"); return ; &#125; for(int i = 1; i&lt;=3; i++) // 这里的i的范围是一步能走多少台阶 &#123; if(sum + i &lt;= n) &#123; a[cnt++] = i; dfs(sum+i,step+1); cnt--; // 返回上一层的时候 下标也要往后退一步 &#125; &#125;&#125;int main()&#123; while(~scanf("%d",&amp;n)) &#123; memset(a,0,sizeof(a)); // 初始化数组 cnt = 0; // 下标初始化 dfs(0,0); &#125; return 0;&#125; 步数限制版本 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int maxn = 1000;int n,cnt,temp,m;int a[maxn];void dfs(int sum,int step)&#123; if(sum == n &amp;&amp; step == m) // 步数限制加在判断里面就ok &#123; cout&lt;&lt;a[0]; for(int i = 1; i&lt;step; i++) &#123; cout&lt;&lt;"-"&lt;&lt;a[i]; &#125; cout&lt;&lt;endl; temp++; // 方法总数 return ; &#125; for(int i = 1; i&lt;=3; i++) &#123; if(sum + i &lt;= n) &#123; a[cnt++] = i; dfs(sum+i,step+1); cnt--; &#125; &#125;&#125;int main()&#123; while(~scanf("%d %d",&amp;n,&amp;m)) &#123; memset(a,0,sizeof(a)); cnt = temp = 0; dfs(0,0); cout&lt;&lt;"方法一共有 "&lt;&lt;temp&lt;&lt;" 种"&lt;&lt;endl; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
</search>
